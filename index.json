[{"content":" 缓冲区和参数列表 :e file :ls! # 创建一个无名缓冲区 :enew #创建本地参数列表 :arglocal #list :args :next :previous :first :last :argadd :argdelete :args 寄存器 标记 补全 \u0026lt;c-x\u0026gt;\u0026lt;c-l\u0026gt; 整行 \u0026lt;c-x\u0026gt;\u0026lt;c-f\u0026gt; 文件名 ","permalink":"https://tazegi.github.io/post/linux/vim/","summary":"","title":"Vim"},{"content":" 网络 容器之间共用ip\ndocker run -it --name alpine1 alpine /bin/sh docker run -it --network container:alpine1 --name alpine2 alpine /bin/sh 自定义网络\ndocker network create alpine_network docker network ls docker run -it --network alpine_network --name alpine1 alpine /bin/sh docker run -it ---network alpine_network --name alpine2 alpine /bin/sh ping alpine1 可以通过容器名ping通\n常用程序 ubuntu\n创建 docker run –privileged -it –name=\u0026#39;ubuntu\u0026#39; registry.cn-hangzhou.aliyuncs.com/evil520/ubuntu /bin/zsh 拷贝\ndocker cp ubuntu:a . 导入导出\ndocker export ubuntu \u0026gt; ubuntu.tar cat ubuntu.tar | docker import - 镜像用户/镜像名:镜像版本号\neg cat ubuntu.tar | docker import - u2:latest 创建镜像\ndocker commit -m=\u0026#39;vim neovim zsh emacs\u0026#39; -a=\u0026#39;evil520\u0026#39; ubuntu evil520/ubuntu:latest 本地镜像发布到阿里云\ndocker login –username=evil520 registry.cn-hangzhou.aliyuncs.com docker tag evil520/ubuntu registry.cn-hangzhou.aliyuncs.com/evil520/ubuntu:latest docker push registry.cn-hangzhou.aliyuncs.com/evil520/ubuntu:latest 阿里云到本地\ndocker pull registry.cn-hangzhou.aliyuncs.com/evil520/ubuntu:latest 绑定容器卷\ndocker run -it –privileged=true -v /宿主机绝对目录:/容器内目录 镜像名 只读(read only) docker run -it –privileged=true -v /宿主机绝对目录:/容器内目录:ro 镜像名 继承 docker run -it –privileged=true –volumes-from container 镜像名 mysql\n安装: docker pull mysql:5.7 创建 docker run -d -p 3306:3306 –privileged –name mysql -e MYSQL_ROOT_PASSWORD=f -v /mysql/log:/var/log/mysql -v /mysql/data:/var/lib/mysql -v /mysql/conf:/etc/mysql/conf.d mysql:5.7 支持utf8的配置\n[client] default_character_set=utf8 [mysqld] collation_server = utf8_general_ci character_set_server = utf8 查看是否是utf8 SHOW VARIABLES LIKE \u0026#39;character%\u0026#39;;\n验证\nshow databases; create database test; use test; create table test(id int,name varchar(20)); insert into test values(1,\u0026#39;张三\u0026#39;); select * from test; portainer\ndocker run -d -p 8000:8000 -p 9443:9443 –name portainer –restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest http://172.17.0.2:9000 容器 docker start 启动容器 进入运行的容器\ndocker exec -it ubuntu /bin/bash #exit退出不会停止 必须加-it和/bin/bash docker attach ubuntu 不要加-it 创建容器 docker run -it –name=\u0026#39;ubuntu\u0026#39; ubuntu /bin/bash\n–name 容器名字 -d 后台运行 正在运行:docker ps\n-a 历史上运行过 -l 最近运行的 -q 只显示容器编号 -n 1 个数 重启,停止\ndocker restart docker stop docker kill # 强制停止 删除\ndocker rm -f 强制 删除全部:docker rm -f ${docker ps -a -q} docker ps -a -q | xargs docker rm 日志\ndocker logs 查看内部细节\ndocker inspect 注意事项 curl -XGET 模拟get请求 镜像 docker pull docker search –limit=5 docker images\n全部: docker images -a 只显示id: -q 占用信息: docker system df 删除镜像: docker rmi\n-f 强制 删除全部: docker rmi -f ${docker images -qa} dockerfile 保留字\nfrom maintainer run expose 8080 暴露端口 workdir user env\n案例\nenv MY_PATH /usr/mytest workdir $MY_PATH and 会自动解压 copy cmd entrypoint 类似于cmd指令,但是entrypoint不会被docker run后面的命令覆盖,而且这些命令行参数会被当作参数送给entrypoint指令指定的程序 docker build -t centosjava8:1.5 . docker-compose 案例\nversion: \u0026#34;3\u0026#34; services: mysql: image: mysql:5.7 container_name: mysql environment: MYSQL_ROOT_PASSWORD: f ports: - \u0026#34;3306:3306\u0026#34; networks: - mysql phpmyadmin: image: phpmyadmin/phpmyadmin:latest container_name: myadmin environment: PMA_HOST: 172.17.0.1 PMA_PORT: 3306 ports: - \u0026#34;8080:80\u0026#34; networks: - mysql depends_on: - mysql networks: mysql: docker-compose config -q docker-compose up -d docker-compose start docker-compose up ","permalink":"https://tazegi.github.io/post/%E8%BF%90%E7%BB%B4/docker/","summary":"","title":"Docker"},{"content":" 疑难解决 grep含有没有高亮的匹配行\n单个字母加星,如r*​,会匹所有行,因为只有一个条件,即r出现0次或多次,没有匹配到的就是0次,满足匹配条件 匹配完整单词: grep -E \u0026#34;^root\\\u0026gt;\u0026#34; passwd 找出2,3位数: grep -E \u0026#34;\\\u0026lt;[0-9]{2,3}\\\u0026gt;\u0026#34; passwd .*​不能匹配空行 删除空行和注释行\nsed \u0026#34;/^;/d\u0026#34; /etc/php/apache2-php8.1/php.ini | sed \u0026#34;/^$/d\u0026#34; sed \u0026#34;/^;\\|^$/d\u0026#34; /etc/php/apache2-php8.1/php.ini sed \u0026#34;/^\\(;\\|$\\)/d\u0026#34; /etc/php/apache2-php8.1/php.ini 注释1到3行:\nsed -r \u0026#39;1,3s/(^.)/#\\1/\u0026#39; passwd awk指定两个分割符\nawk -F \u0026#34;[ :]\u0026#34; \u0026#39;!/^$/{print $4}\u0026#39; # !/^$ 不输入空行 awk -F: \u0026#39;$3\u0026gt;=1000{print $1,$(NF-1)}\u0026#39; /etc/passwd {}命令行展开\necho {1..5} echo {1..5..2} echo {a..z} grep去除空行\ngrep \u0026#39;^$\u0026#39; \u0026lt;file\u0026gt; -v 正则表达式 grep -E\n​ *前一个字符零次到多次\n和linux的星不同, .*同linux的星 \\ 转义 a{n,m} 匹配前一个字符最少n次,最多m次 a{n,} 匹配前一个字符最少n次 a{m} 匹配前一个字符最多m次 grep 实战\n找出以 至少 1个 空白字符 开头开头,后面是 非空字符 的行\n# 1 grep \u0026#34;^[[:space:]].*\u0026#34; ety.org # 2 grep -E \u0026#34;^[[:space:]]+[^[:space:]]\u0026#34; ety.org 找出所有以I,i开头的行\n(|)和[]在字符只有1个时有相同的含义\ngrep -i \u0026#34;^i\u0026#34; *.org grep -E \u0026#34;^(i|I)\u0026#34; *.org grep \u0026#34;^[iI]\u0026#34; *.org 找出所有函数名:\ngrep -E \u0026#34;[a-zA-Z]+\\(\\)\u0026#34; /etc/init.d/functions.sh 找出用户名和shell相同的用户:\ngrep -E \u0026#34;^([^:]+\\\u0026gt;).*\\1$\u0026#34; /etc/passwd 选项\n-i ignorecase -o 仅显示匹配到的字符串本身 -v -​-invert-match 显示不能被模式匹配到的行 -E 支持扩展正则 -n 显示行号 -q 静默模式,即不输入任何信息 -c 输出匹配的次数 -m 匹配几次就停止 -l 列出匹配的文件名 sed 命令字符: a,d,i,p,s 匹配范围\n空地址 全文处理 单地址 指定某一行 pattern 被模式匹配到的每一行 范围区间 10,20 10到20行, 10,+5 第10行向下5行 步长 1~2,表示1,3,,5,7,9行, 2~2两个步长,表示2,4,6,10 多次编辑: sed -e \u0026#34;1p\u0026#34; -e \u0026#34;2p\u0026#34; passwd -n\n# -e必须紧跟命令字符 sed -n -e \u0026#34;1p\u0026#34; -e \u0026#34;2p\u0026#34; passwd sed -e \u0026#34;1p\u0026#34; -e \u0026#34;2p\u0026#34; -n passwd 参数选项\n-n 取消默认输出,常与*命令字符*p一起用 -i 写入文件 -e 多次编辑,不需要管道符了 -r 支持正则 实战\n# 输出第1,3行: sed -n \u0026#39;1,3p\u0026#39; passwd # 过滤: sed \u0026#39;/root/p\u0026#39; -n passwd # 删除第一行,相当于vim的dd sed \u0026#39;1d\u0026#39; passwd # 向下追加,相当于vim的o sed \u0026#39;1i test insert\u0026#39; passwd # 添加多行,通过\\n换行: sed \u0026#39;1i test\\nnow line\u0026#39; passwd # 测试空地址: sed \u0026#39;a---------------\u0026#39; passwd awk 注意事项\nawk用单引号,字符串用双引号 正则区间: awk \u0026#39;​//,//\u0026#39; 指定两个分割符: awk -F \u0026#34;[ :]\u0026#34; \u0026#39;!/^$/{print $4}\u0026#39; 选项\n-F 指定分割符 -v 定义或修改一个awk内部的变量 -f 从脚本文件读取awk命令 内置变量\n$0 打印每列 FS 字段分隔符 OFS 输出字段分隔符 NR (Number of records) 记录数 NF (Number of fields) 字段数 RS 输入记录分隔符 ORS 输出记录分隔符 FNR 各文件分别的行号 FILENAME 当前文件名 ARGC 命令行参数个数 ARCV 数组,保存的是命令行所给定的各参数(0:awk, 1:file) 实战\n# awk打印HelloWorld: awk \u0026#39;BEGIN{print \u0026#34;HelloWorld\u0026#34;}\u0026#39; # 输出2和3列: pp | awk \u0026#39;{print $2,$3}\u0026#39; # 输出倒数第1列: pp | awk \u0026#39;{print $NF}\u0026#39; # 输出第1行: awk \u0026#39;NR==1{print}\u0026#39; passwd # 输出1到3行: awk \u0026#39;NR==1,NR==3{print}\u0026#39; passwd # 指定分割符: awk -F : \u0026#39;{print $1}\u0026#39; passwd # 等同: awk -v FS=\u0026#34;:\u0026#34; \u0026#39;{print $1}\u0026#39; passwd # 给每行添加行号 (cat -n): awk \u0026#39;{print NR,$0}\u0026#39; passwd # 处理多个文件分别显示行号: awk \u0026#39;{print FNR,$0}\u0026#39; passwd passwd # 自定义变量: awk -v name=\u0026#34;evil520\u0026#34; \u0026#39;BEGIN{print \u0026#34;我的名字是? \u0026#34;,name}\u0026#39; # 过滤: awk \u0026#39;/root/{print}\u0026#39; passwd printf\n左对齐: %-20s\nawk -F: \u0026#39;{printf \u0026#34;%-15s%s\\n\u0026#34;,$1,$NF}\u0026#39; passwd awk的模式: \u0026lt; \u0026lt;= = ! \u0026gt;= \u0026gt; ~(匹配正则) !~(不匹配正则)\n# 输出1到3行: awk \u0026#39;NR==1,NR==3{print}\u0026#39; passwd # 不输出第1行: pp | awk \u0026#39;NR!=1{print}\u0026#39; passwd # 字段~正则,过滤以S开头的第5个字段 awk -F: \u0026#39;$5~/^S/{print}\u0026#39; passwd 统计nginx日志\n# 统计日志的访客ip数量 awk \u0026#39;{print $1}\u0026#39; access.log | sort -n | uniq | wc -l # 查看访问最频繁的前10个ip awk \u0026#39;{print $1}\u0026#39; access.log | sort -n | uniq -c | wc -l | sort -nr | head -10 ","permalink":"https://tazegi.github.io/post/%E8%BF%90%E7%BB%B4/awk/","summary":"","title":"Awk"},{"content":" gentoo wiki 安装 cat /etc/portage/make.conf USE=\u0026#34;apache2\u0026#34; emerge --ask --changed-use --deep @world 启用php支持 cat /etc/conf.d/apache2 APACHE2_OPTS=\u0026#34;... -D PHP\u0026#34; 检查 /etc/apache2/modules.d/70_mod_php.conf 文件是否有内容\n\u0026lt;IfDefine PHP\u0026gt; # The mod_php.so symlink is controlled by # eselect-php. However, the module name changed from # php5_module to php7_module so we can\u0026#39;t blindly load whatever # is there. Instead we let eselect-php manage a small # configuration file that loads the appropriate module. # # This is relative to ServerRoot (see httpd.conf). Include ../../../var/lib/eselect-php/mod_php.conf # Tell apache that mod_php should handle PHP files. # # NOTE: Avoiding AddHandler/AddType for security (bug # #538822). Please read the related news item! \u0026lt;FilesMatch \u0026#34;\\.(php|php[57]|phtml)$\u0026#34;\u0026gt; SetHandler application/x-httpd-php \u0026lt;/FilesMatch\u0026gt; # PHP source files which are meant to be displayed as # syntax-highlighted source code. \u0026lt;FilesMatch \u0026#34;\\.phps$\u0026#34;\u0026gt; SetHandler application/x-httpd-php-source \u0026lt;/FilesMatch\u0026gt; DirectoryIndex index.php index.phtml \u0026lt;/IfDefine\u0026gt; mvs /var/www/localhost/htdocs/index.html{,.bak}\n验证php模块是否工作 /var/www/localhost/htdocs/index.php\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;?php phpinfo(); ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; open the test page: https://localhost/\n修改php版本 eselect php list apache2 eselect php set apache2 N 虚拟主机 创建虚拟主机\nDocumentRoot是一个文件夹\n/etc/apache2/vhosts.d/VirtualHost.conf\n\u0026lt;VirtualHost *:80\u0026gt; ServerAdmin email@site.com DocumentRoot /var/www/website1 ServerName domainname1.com \u0026lt;/VirtualHost\u0026gt; \u0026lt;VirtualHost *:80\u0026gt; ServerAdmin email@site.com DocumentRoot /var/www/website2 ServerName domainname2.com \u0026lt;/VirtualHost\u0026gt; \u0026lt;Directory /var/www/\u0026gt; Options Indexes FollowSymLinks AllowOverride None Require all granted \u0026lt;/Directory\u0026gt; 创建虚拟主机文件\nDocumentRoot是一个文件夹\nmkdir /var/www/website1\nthis is website1 mkdir /var/www/website2\nthis is website2 修改虚拟主机文件权限\nsudo -i chown apache:apache /var/www/website/* ","permalink":"https://tazegi.github.io/post/%E8%BF%90%E7%BB%B4/apache2/","summary":"","title":"Apache2"},{"content":" gentoo wiki sudo emerge --config =dev-db/mysql-8.0.31-r1 rc-update add mysql default; rc-service mysql start mysql_secure_installation # 禁用历史记录: ln -sf /dev/null ~/.mysql_history docker的phpmyadmin 和远程访问一个道理，要想从容器中的phpMyAdmin访问运行在服务器上的MySQL，必须先修改MySQL配置文件，允许非localhost的IP访问。\n打开/etc/mysql/mysql.d/50-distro-server.cnf配置文件，进行如下修改： bind-address = localhost # 找到上式，修改为 bind-address = xxx.xx.xx.x # 你的docker0的ip地址 # 或者修改为 bind-address = 0.0.0.0 # 表示允许任意ip地址访问 然后，还需要将你的账号也设置为允许从远程登陆（默认为localhost）。为了完成这一操作，先通过localhost登入mysql，更改mysql数据库里的user表里对应你账号的host项，从localhost改成%。具体操作如下：\n# 使用mysql数据库 use mysql; # 将root账号（可替换成其他）的host修改为% update user set host = \u0026#39;%\u0026#39; where user = \u0026#39;root\u0026#39;; # 查看修改结果 select host, user from user; 最后，不要忘记重启mysql 创建phpMyAdmin镜像\n# PMA_HOST设置为连接的MySQL主机名或ip地址 # PMA_PORT设置为端口号 # 8080:80，将宿主机的8080端口映射到镜像的80端口 docker run -d \\ --name myadmin \\ -e PMA_HOST=$(ip route show | grep docker0 | awk \u0026#39;{print $9}\u0026#39;) \\ -e PMA_PORT=3306 \\ -p 8080:80 \\ phpmyadmin/phpmyadmin 值得一提的是，这里是通过桥接网络模式（bridge mode）运行的镜像，因此在镜像中可通过docker0访问宿主网络。\n此时，可以通过8080端口访问到phpMyAdmin的管理界面了，即 http://127.0.0.1:8080/ One More Thing\n把MySQL随意地暴露在网络下无疑会带来安全隐患，从安全角度考虑，应该为防火墙设置白名单规则，只有白名单的IP才能够连接数据库。\n# ufw防火墙，提供一个参考思路而已 ufw insert 1 allow from 172.17.0.3 to any port 3306 技巧 %和_是通配符 show variables like \u0026#39;skip_name\u0026#39;;\n查询变量, gentoo无此变量 skip_name_resolve = on 禁止主机名解析,建议使用 查询3个字符的变量\nshow variables like \u0026#39;___\u0026#39;; 数据库存在也不会报错\ncreate database if not exists db1; drop database if exists db1; 指定字符集\ncreate database db2 default charset utf8mb4; 查看字符集\n-- 查看表的字符集 show create table table; -- 查看库的字符集 show create database database; -- 查看DBMS的字符集 show variables like \u0026#39;character_%\u0026#39;; -- 查看比较规则 show variables like \u0026#39;collation_%\u0026#39;; 脚本模式\nmysql -uroot -pf \u0026lt; /path/to/somefile.sql mysql\u0026gt; source somefile.sql 去重:distinct\nuse test; create table repetition(id int); insert into repetition values(1); insert into repetition values(1); insert into repetition values(1); select * from repetition; -- 去重 select distinct * from repetition; 着重号 ``\n如果出现了字段名,表名跟关键字重名,要明确加上着重号,表示就是一个普通的字段,表名 查询常数\n-- 查询尚硅谷的全部学生(全部学生都在尚硅谷) select \u0026#39;尚硅谷\u0026#39;,student_id,student_name from school; 查询正在使用的数据库\nselect database(); -- 查看用户: select user(); root@localhost root@localhost和root@127.0.0.1是不同账号 前者走socket,后者走tcp/ip 修改mysql的PS1 man mysql\n• Use an option file. You can set the prompt option in the [mysql] group of any MySQL option file, such as /etc/my.cnf or the .my.cnf file in your home directory. For\nexample:\n[mysql]\nprompt=(\\\\u@\\\\h) [\\\\d]\u0026gt;\\\\_\n常用选项 -A 禁止补全 -P port -S socket -D 指定默认数据库\n默认不写也是\nmysql -uroot -pf mysql -C 启用压缩 -e 执行sql命令\nmysql -uroot -pf -e \u0026#34;show databases;status;\u0026#34; -V 查看版本 -v verbose --print-defaults\nmysql --print-defaults mysqld --print-defaults 配置文件 _和-相同 0,OFF,FALSE意义相同,1,ON,TRUE意义相同 mysqld: skip-network=1\n关闭网络 3306端口将关闭 但本地仍然可以通过socket连接 需要重启服务 二进制安装 useradd -r -d /data/mysqldb -s /sbin/nologin mysql 系统账号默认不会创建家目录 tar xvf mariadb-num-linux-x86_64,tar.gz -C usr/local cd usr/local ln -s mariadb-num-linux-x86_64 mysql chow -R root: mysql/ 将/usr/local/mysql/bin加入环境变量 mkdir /data/mysqldb chown mysql.mysql /data/mysqldb chmod 770 /data/mysqldb cp support-files/my-huge.cnf /etc/my.cnf 选择my-huge.cnf作为主要配置 scripts/mysql_install_db –datadir=/data/mysqldb –user=mysql 生成数据库文件\n可能需要安装的包\nperl-Data-Dumper libaio 修改配置文件,在配置文件中指定数据库\n[mydqld] datadir = /data/mysqldb socket = /usr/local/mysql/mysql.sock [client] socket = /usr/local/mysql/mysql.sock cp support-files/mysql.server /etc/init.d/mysqld 拷贝服务文件 chkconfig –add mysqld 开机启动 service mysqld start 由于sock文件在/usr/local/mysql/mysql.sock没有写权限,启动失败 setfacl -R -m u:mysql:rwx /usr/local/mysql mysql_secure_installation 取消sock路径的修改 子命令help system: 执行shell命令\nsystem hostname 或 \\! hostname status\n查看状态 包括版本,当前用户,当前使用数据库,编码 或 \\s 客户端命令与服务器命令 客户端命令\n通过客户端执行 help下的命令 不需要加分号 服务器命令\n服务器端执行 需要加分号 mysqladmin mysqladmin -uroot -pf password mysql mysqladmin -uroot -pmysql password mysqladmin -uroot -pf create db1 mysqladmin -uroot -pf drop db1 #检测健康状态 mysqladmin -uroot -pf ping mysqladmin -uroot -pf ping \u0026amp;\u0026gt; /dev/null || systemctl restart mariadb #关闭数据库 mysqladmin -uroot -pf shutdown 对应关系 1对多\n员工表的部门id和部门表的id,1个部门有多个员工\n外键表信赖于主键表,员工表的department_id信赖于部门表的id 所以id是主键,department_id是外键 多对多\n学生表(student)课程表(course)\n分别取出学生id和课程id组成第三张表 sid信赖学生数目,cid信赖课程数目,都是外键 多表查询 简单的多表查询\nselect emp.employee_id,dept,depart_name,emp.department_id from employees emp,departments dept where emp.department_id = dept.department_id; -- 当员工的部门id和部门表的部门id相等时,打印部门名字 employees:职位表 departments:公寓表\n等值连接,非等值连接\nselect e.last_name,e.salary,j.grade_level from employees e,job_grades j where e.salary \u0026gt;= j.lowest_sal and e.highest_sal; -- 当员工工资在某个区间上时,打印工资等级 employees:职位表 job_grades:公资等级表\n自连接,非自连接\nselect emp.employee_id,emp.last_name,mgr.employee_id,mgr.last_name fron employees emp,employees mgr where emp.manager_id = mgr.employee_id; -- 当员工的管理者id和员工id相等时,查询管理者id和名字 内连接\nselect emp.employee_id,dept,depart_name,emp.department_id from employees emp join departments dept on emp.department_id = dept.department_id; -- 当员工的部门id和部门表的部门id相等时,打印部门名字 左外连接\nselect emp.employee_id,dept,depart_name,emp.department_id from employees emp left join departments dept on emp.department_id = dept.department_id; -- 当员工的部门id和部门表的部门id相等时,打印部门名字 右外连接\nselect emp.employee_id,dept,depart_name,emp.department_id from employees emp right join departments dept on emp.department_id = dept.department_id; -- 当员工的部门id和部门表的部门id相等时,打印部门名字 union,union all 连接两个表,但union会去重 满外连接 规范 字符串单引,列别名双引 关键字大写 普通语法 注释\n# * * – (其它数据库通用) 转义符:\\ databases show databases; use database; create database database; drop database database; tables show tables; create table table(id int,name varchar(15)); insert into table values(1,\u0026#39;Tom\u0026#39;); select * from table; # 显示表结构 describe table; desc table; select select 5+4; select 5+4 from dual; select 字断名 from 表名;\nuse mysql; select cost_name,last_update from engine_cost; 列的别名\nuse mysql; select cost_name cname,last_update lupdate from engine_cost; select cost_name AS cname,last_update AS lupdate from engine_cost; select cost_name AS \u0026#34;cost名\u0026#34;,last_update AS \u0026#34;日期\u0026#34; from engine_cost; 别名用双引\n空值参于运算\ncreate table NULLoperation(value int,times int); show create table NULLoperation\\G select value,times,value*times from NULLoperation; insert into NULLoperation values(3,null); select value,times,value*times from NULLoperation; select value,times,value*ifnull(times,0) from NULLoperation; -- 空植用零替换: ifnull(times,0) 空值参于运算的结呆一定为空 空值不等于零\n过滤条件\nselect 1,value,times,value*ifnull(times,1) from NULLoperation where times=10; where放在from的后面\n比较 不等于:\u0026lt;\u0026gt;,同!= 安全等于:*\u0026lt;=\u0026gt;* 可以对NULL进行判断,而不返回NULL,等号有NULL参于就返回NULL is null, is not null, isnull() least(), greatest() beteen and 包含边界 in (), not in () not/!, and/\u0026amp;\u0026amp;, or/||, xor(逻辑异或) *not用在where后面 like:模糊查询\nlike放在where后面过滤输出结果,多个条件用or,and select 1,value,times,value*ifnull(times,1) from NULLoperation where times like \u0026#39;1%\u0026#39;; select from where like \u0026#39;%a%\u0026#39; %号同linux的星 select from where like \u0026#39;_a%\u0026#39; (查询第二个字符是a的结果) _同正则表达式的点 regexp/rlike:正则表达式\nregexp/rlike放在where后面过滤输出结果,多个条件用or,and select 1,value,times,value*ifnull(times,1) from NULLoperation where times regexp \u0026#39;1.\u0026#39;; 排序 order by 字段 [asc] (ascend) order by 字段 desc (descend) 列的别名只能在order by中使用,不能在where中使用 二级排序 在一级排序的结果相同时,再进行排序\norder by 字段 desc 字段 [asc] *升序可省略asc 分页 limit 偏移量,条数\neg limit [0],20 (每页显示20条数据,此时显示第1页) 偏移量为零可省略 eg limit 20,20 (每页显示20条数据,此时显示第2页) eg limit 40,20 (每页显示20条数据,此时显示第3页) 公式: limit (pageNo-1)*pageSize,pageSize; mysql8.0新特性: limit 条数 offset 偏移量 约束 主键约束\ncreate table user( id int primary key auto_increment comment \u0026#39;主键\u0026#39;, name varchar(10) not null unique comment \u0026#39;姓名\u0026#39;, age int check ( age \u0026gt; 0 \u0026amp;\u0026amp; age \u0026lt;= 120 ) comment \u0026#39;年龄\u0026#39;, status char(1) default \u0026#39;1\u0026#39; comment \u0026#39;状态\u0026#39;, gender char(1) comment \u0026#39;性别\u0026#39; ) comment \u0026#39;用户表\u0026#39;; 外键约束\nalter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id); emp表的dept_id信赖dept表的id 删除\nalter table emp drop foreign key fk_emp_dept_id 事务 查询\n(root@localhost) [test]\u0026gt; select @@autocommit; +--------------+ | @@autocommit | +--------------+ | 1 | +--------------+ 1 row in set (0.00 sec) set @@autocommit = 0; 手动提交\nset @@autocommit = 0; commit; -- 回滚事务 rollback; start transaction; 事务隔离级别\n查询\n(root@localhost) [test]\u0026gt; select @@transaction_isolation; +-------------------------+ | @@transaction_isolation | +-------------------------+ | REPEATABLE-READ | +-------------------------+ 1 row in set (0.00 sec) set session transaction isolation level read_uncommitted; 日志 二进制日志 对库的修改\n(root@localhost) [(none)]\u0026gt; show variables like \u0026#39;%log_bin%\u0026#39;; +---------------------------------+---------------------------------+ | Variable_name | Value | +---------------------------------+---------------------------------+ | log_bin | ON | | log_bin_basename | /var/lib/mysql/gentoo-bin | | log_bin_index | /var/lib/mysql/gentoo-bin.index | | log_bin_trust_function_creators | OFF | | log_bin_use_v1_row_events | OFF | | sql_log_bin | ON | +---------------------------------+---------------------------------+ 6 rows in set (0.00 sec) 查看日志格式\n(root@localhost) [(none)]\u0026gt; show variables like \u0026#39;%binlog_format\u0026#39;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | binlog_format | ROW | +---------------+-------+ 1 row in set (0.01 sec) mysqlbinlog gentoo-bin.000003 -v 格式为ROW要加-v 删除日志\nreset master 删除全部 purge master logs to \u0026#39;binlog.***\u0026#39; 删除***之前的所有日志 purge master logs before \u0026#39;yyyy-mm-dd hh:mm:ss\u0026#39; 过期时间\n(root@localhost) [(none)]\u0026gt; show variables like \u0026#39;%binlog_expire%\u0026#39;; +-------------------------------+---------+ | Variable_name | Value | +-------------------------------+---------+ | binlog_expire_logs_auto_purge | ON | | binlog_expire_logs_seconds | 2592000 | +-------------------------------+---------+ 2 rows in set (0.00 sec) 30天后会自动删除\n查询日志 对库的查询\n(root@localhost) [(none)]\u0026gt; show variables like \u0026#39;%general%\u0026#39;; +------------------+---------------------------+ | Variable_name | Value | +------------------+---------------------------+ | general_log | OFF | | general_log_file | /var/lib/mysql/gentoo.log | +------------------+---------------------------+ 2 rows in set (0.00 sec) 查询日志默认关闭\n慢查询日志\n开启慢查询\n#开启慢查询 slow_query_log=1 #慢查询时间参数 long_query_time=2 主从复制 主库配置\n/etc/my.cnf\nserver-id=1 read-only=0 创建用户\ncreate user \u0026#39;f\u0026#39;@\u0026#39;%\u0026#39; identified with mysql_native_password by \u0026#39;f\u0026#39;; 授于权限\ngrant replication slave on *.* to \u0026#39;f\u0026#39;@\u0026#39;%\u0026#39;; 查看二进制日志坐标\nshow master status; 从库配置\n/etc/my.cnf\nserver-id=2 read-only=1 8.0.23之前\nchange replication source to source_host=\u0026#39;xxx.xxx\u0026#39;,source_user=\u0026#39;xxx\u0026#39;,source_log_file=\u0026#39;xxx\u0026#39;,source_log_pos=xxx; 如果是8.0.23之前的版本,执行如下sql:\nchange replication master to master_host=\u0026#39;xxx.xxx\u0026#39;,master_user=\u0026#39;xxx\u0026#39;,master_log_file=\u0026#39;xxx\u0026#39;,master_log_pos=xxx; 开启同步操作\nstart replica; #8.0.22之后 start slave; #8.0.22之前 查看主从同步状态\nstart replica status\\G; #8.0.22之后 start slave status\\G; #8.0.22之前 查看replica_io_running和replica_sql_running是否为yes ","permalink":"https://tazegi.github.io/post/%E8%BF%90%E7%BB%B4/mysql/","summary":"","title":"Mysql"},{"content":" 排错 ping不通\n➜ ~ ansible all -k -m ping SSH password: [ERROR]: User interrupted execution ➜ ~ ansible all -k -m ping -u root SSH password: 192.168.122.45 | SUCCESS =\u0026gt; { \u0026#34;ansible_facts\u0026#34;: { \u0026#34;discovered_interpreter_python\u0026#34;: \u0026#34;/usr/bin/python3\u0026#34; }, \u0026#34;changed\u0026#34;: false, \u0026#34;ping\u0026#34;: \u0026#34;pong\u0026#34; } ➜ ~ ansible all -m ping -u root 192.168.122.45 | SUCCESS =\u0026gt; { \u0026#34;ansible_facts\u0026#34;: { \u0026#34;discovered_interpreter_python\u0026#34;: \u0026#34;/usr/bin/python3\u0026#34; }, \u0026#34;changed\u0026#34;: false, \u0026#34;ping\u0026#34;: \u0026#34;pong\u0026#34; } 配置文件 gentoo wiki 注意: 使用非root用户时,ansible使用~/.ansible.cfg作为配置文件,使用/etc/ansible/hosts作为主机清单 生成/etc/ansible/ansible.cfg\nsudo -s mkdir /etc/ansible/ ansible-config init --disabled | sudo tee /etc/ansible/ansible.cfg #或 sudo sh -c \u0026#34;ansible-config init --disabled \u0026gt; /etc/ansible/ansible.cfg\u0026#34; #一步 sudo sh -c \u0026#34;mkdir /etc/ansible/; ansible-config init --disabled \u0026gt; /etc/ansible/ansible.cfg\u0026#34; #查看当前使用配置 ansible-config view #为f复制一份 cps /etc/ansible/ansible.cfg .ansible.cfg hosts\n➜ ~ cat /etc/ansible/hosts [opel] 192.168.122.45 #192.168.3.11 日志\nsudo sh -c \u0026#34;touch /var/log/ansible.log; chown f:f /var/log/ansible.log\u0026#34; /etc/ansible/ansible.cfg 开启日志: log_path=/var/log/ansible.log 关闭检查key: host_key_checking = False 主机清单 /etc/ansible/hosts 分组\n[opel] 192.168.122.45 列出目前所有管理的主机列表 ansible all --list # 查看websrvs分组的主机列表 ansible websrvs --list 查看帮助 ansible-doc ping ansible-doc -s ping 批量推送公钥 IPLIST=\u0026#34; 10.0.0.8 10.0.0.7\u0026#34; rpm -q sshpass \u0026amp;\u0026gt; /dev/null || yum -y install sshpass [ -f /root/.ssh/id_rsa ] || ssh-keygen -f /root/.ssh/id_rsa -P \u0026#34;\u0026#34; export SSHPASS=centos #远程主机root密码 for ID in $IPLIST;do sshpass -e ssh-copy-id -o StrictHostKeyChecking=no $IP done 调用模块 # 测试远程主机是否能进行shh连接 ansible all -m ping # 以密码连接 ansible all -k -m ping ansible的Host-pattern 用于匹配被控制的主机列表\nAll:表示Inventory中的所有主机列表 ansible all -m ping *:通配符\nansible \u0026#34;*\u0026#34; -m ping ansible \u0026#34;192.168.1.*\u0026#34; -m ping ansible \u0026#34;*srvs\u0026#34; -m ping 或关系\nansible \u0026#34;websrvs:appsrvs\u0026#34; -m ping 与关系\nansible \u0026#34;websrvs:\u0026amp;appsrvs\u0026#34; -m ping 非关系\nansible \u0026#39;websrvs:!appsrvs\u0026#39; -m ping 必须用单引号,!表历史\n应用场景\n先将其他机器关机,再关自己\nansible \u0026#39;all:!10.0.0.18\u0026#39; -a reboot;reboot 常用工具 加密\nansible-vault encrypt hello.yml ansible-vault decrypt hello.yml ansible-vault view hello.yml ansible-vault edit hello.yml ansible-vault rekey hello.yml ansible-vault create new.yml ansible-console 交互命令\nlist # 切换组 cd 分组名 ping # 设置并发数 forks 10 常用模块 Command 此命令不支持 $VARNAME \u0026lt; \u0026gt; | ; \u0026amp; 等,用 shell 模块实现\nansible-doc -s command ansible all -m command -a \u0026#39;hostname\u0026#39; # 同 ansible all -a \u0026#39;hostname\u0026#39; 查看默认模块\ncat /etc/ansible.cfg module_name=command 参数 语法\nansible all -a \u0026#34;chdir=/data touch b.txt\u0026#34; chdir 进入目录 creates 如果文件存在就 不执行 removes 如果文件存在就 执行 Shell ansible-doc -s shell # 修改默认模块 cat /etc/ansible.cfg module_name=shell # 查看详细执行过程 # -a后面跟单引 ansible all -vvv -a \u0026#39;ls\u0026#39; Script 在远程主机执行shell脚本\nansible all -m scipt -a \u0026#39;/root/test.sh\u0026#39; Copy ansible-doc -s copy\n参数 src\n如果文件夹以 / 结束,仅仅复制文件夹里面的 内容 如果 不 以 / 结束,复制目录 本身和内容,和 rsync 类似 语法\nansible websrvs -m copy -a \u0026#39;src=/root/test1.sh dest=/tmp/test2.sh owner=evil520 mode=600 backup=yes\u0026#39; # backup=yes 覆盖时备份 # 生成文件 ansible websrvs -m copy -a \u0026#39;content=\u0026#34;line1\\nline2\u0026#34; dest=/tmp/test.txt\u0026#39; Fetch 从远程主机抓取文件到ansible的机器上,目前 不支持目录\nansible websrvs -m fetch -a \u0026#39;src=/etc/os-release dest=/data/\u0026#39; # 会建立名为各远程主机ip的文件夹 File 创建文件 state=touch\nansible websrvs -m file -a \u0026#39;path=/data/file.log state=touch mode=000 owner=evil520 group=bin\u0026#39; 创建文件夹 state=dirtory\nansible websrvs -m file -a \u0026#39;path=/data/dir state=dirtory\u0026#39; # state=absent 删除 ansible websrvs -m file -a \u0026#39;path=/data/file.log state=absent\u0026#39; 创建软链接 state=link\nansible websrvs -m file -a \u0026#39;src=/data/file.log state=link dest=/tmp/file.log.link\u0026#39; Unarchive 解压缩\n参数 copy 默认为yes,当copy=yes,拷贝的文件是从ansible主机复制到远程主机上,如果设置为copy=no,会在远程主机上寻找src源文件 remote_src 各copy功能一样且互斥 范例\nansible all -m unarchive -a \u0026#39;src=/data/foo.tgz dest=/var/lib/foo owner=f group=bin\u0026#39; ansible all -m unarchive -a \u0026#39;src=/tmp/foo.zip dest=/data copy=no mode=0777\u0026#39; ansible all -m unarchive -a \u0026#39;src=http​s://example.example.zip dest=/data copy=no\u0026#39; Hostname ansible node1 -m hostname -a \u0026#34;name=websrvs\u0026#34; Cron # 创建 ansible websrvs -m cron -a \u0026#39;hour=2 minute=30 weekday=1-5 name=\u0026#34;back mysql\u0026#34; job=/root/mysql_backup.sh\u0026#39; # 禁用 ansible websrvs -m cron -a \u0026#39;hour=2 minute=30 weekday=1-5 name=\u0026#34;back mysql\u0026#34; job=/root/mysql_backup.sh disabled=yes\u0026#39; # 启用 ansible websrvs -m cron -a \u0026#39;hour=2 minute=30 weekday=1-5 name=\u0026#34;back mysql\u0026#34; job=/root/mysql_backup.sh disabled=no\u0026#39; # 删除 ansible websrvs -m cron -a \u0026#39;state=absent name=\u0026#34;back mysql\u0026#34;\u0026#39; Yum ansible websrvs -m yum -a \u0026#39;name=iotop,cowsay\u0026#39; #state=absent 卸载 Service ansible websrvs -m service -a \u0026#39;name=vsftpd state=started enabled=yes\u0026#39; state=stopped 停止服务 state=restarted 重启服务 User # 创建 ansible all -m user -a \u0026#39;name=user1 commit=\u0026#34;test user\u0026#34; uid=2048 home=/app/user1 group=root\u0026#39; # 创建系统用户 ansible all -m user -a \u0026#39;name=nginx commit=nginx uid=88 group=nginx groups=\u0026#34;root,daemon\u0026#34; shell=/sbin/nologin system=yes create_home=no\u0026#39; # 删除 ansible all -m user -a \u0026#39;name=user1 state=absent remove=yes\u0026#39; Group ansible websrvs -m group -a \u0026#39;name=nginx gid=88 system=yes\u0026#39; Lineinfile 修改文件某行 ansible all -m lineinfile -a \u0026#39;path=/etc/selinux/config regexp=\u0026#34;^SELINUX=\u0026#34; line=\u0026#34;SELINUX=disabled\u0026#34;\u0026#39; # state=absent 删除某行 Replace ansible all -m replace -a \u0026#39;path=/etc/fstab regexp=\u0026#34;^(UUID.*)\u0026#34; replace=\u0026#34;#\\1\u0026#34;\u0026#39; Setup ansible websrvs -m setup -a \u0026#39;filter=ansible_distribution\u0026#39;\nfilter\nansible_nodename 主机名 ansible_os_family 操作系统家族 ansible_distribution 操作系统 ansible_memtotal_mb 内存大小 ansible_all_ipv4_address ip ansible_default_ipv4 默认ip ansible执行原理 将python脚本复制到远程执行,如果远程缺少信赖包将导致执行失败\nplaybook ansible-playbook -C hello.yml 检查语法\n第一个yaml文件: hello.yml --- - hosts: all remote_user: root tasks: - name: 是否正常 ping: - name: 查看OS版本 setup: filter=ansible_distribution_major_version - name: 查看时间 shell: date hosts: websrvs:appsrvs websrvs和appsrvs列表\n选项 --list-hosts --list-tasks\n➜ ~ ansible-playbook --list-hosts hello.yml playbook: hello.yml play #1 (all): all\tTAGS: [] pattern: [\u0026#39;all\u0026#39;] hosts (1): 192.168.122.45 ➜ ~ ansible-playbook --list-tasks hello.yml playbook: hello.yml play #1 (all): all\tTAGS: [] tasks: 是否正常\tTAGS: [] 查看OS版本\tTAGS: [] 查看时间\tTAGS: [] --limit 只针对主机列表中的特定主机执行 handle,notify 当文件改变时执行\ntasks: - name: Install httpd yum: name=httpd state=present - name: Install configure file copy: src=files/httpd.conf dest=/etc/httpd/conf/ notify: restart service - name: modify config lineinfile: path=/etc/httpd/conf/httpd.conf regexp=\u0026#39;^Listen\u0026#39; line=\u0026#39;Listen 6666\u0026#39; notify: restart service - name: mkdir website dir file: path=/data/html state=directory - name: web html copy: files/index.html dest=/data/html/ - name: start service service: name=httpd state=started enable=yes handlers: - name: restart service service: name=httpd state=restarted tags 选择同一类标签执行\ntasks: - name: Install httpd yum: name=httpd state=present - name: Install configure file copy: src=files/httpd.conf dest=/etc/httpd/conf/ tags: conf notify: restart service - name: modify config lineinfile: path=/etc/httpd/conf/httpd.conf regexp=\u0026#39;^Listen\u0026#39; line=\u0026#39;Listen 6666\u0026#39; tags: conf notify: restart service - name: mkdir website dir file: path=/data/html state=directory - name: web html copy: files/index.html dest=/data/html/ tags: html - name: start service service: name=httpd state=started enable=yes handlers: - name: restart service service: name=httpd state=restarted ansible-playbook --list-tags install_httpd.yml ansible-playbook -t html install_httpd.yml 变量 set模块变量\n--- - hosts: websrvs remote_user: root gather_faces: yes tasks: - name: create log file file: name=/data/{{ ansible_nodename }}.log state=touch owner=wang mode=600 ansible-playbook var1.yml\n在命令行定义变量\n--- - hosts: all remote_user: root tasks: - name: install package yum: name={{ pkname }} state=present # 临时替换变量 alsible-playbook -e pkname=httpd var.yml 在playbook文件中定义变量\n--- - hosts: all remote_user: root vars: - username: user1 - groupname: group1 tasks: - name: create group group: name={{ groupname }} state=present - name: create user user: name={{ username }} group={{ groupname }} state=present alsible-playbook -e \u0026#34;username=user2 groupname=user2\u0026#34; var.yml -e的优先级更高 主机变量和分组变量\n[opel] 192.168.122.45 hname=www1 192.168.3.11 hname=www2 [opel:vars] domain=evil520.org 模板 template文件必须存放于templates目录下,且命名为.j2结尾 范例: 利用template同步nginx配置文件\nmkdir templates cat templates/nginx.conf.j2 worker_processes {{ ansible_processor_vcpus }}; #temnginx2.yml --- - hosts: websrvs remote_user: root tasks: - name: template config to remote hosts template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf ","permalink":"https://tazegi.github.io/post/%E8%BF%90%E7%BB%B4/ansible/","summary":"","title":"Ansible"},{"content":" ssh 选项\n-x 远程执行图形程序 -t 多次连接到目标\n格式: ssh -t IP -t IP -t IP\n从第1个IP连接到第2个IP,再从第2个IP连接到第3个IP -o 临时修改配置 如: -o StrictHostChecking=no 在远程执行本地脚本\nssh IP bash \u0026lt; test2.sh 禁用首次用ssh时的询问: sed -i.bak \u0026#39;/StrictHostChecking/s/.*/StrictHostChecking no/\u0026#39; /etc/ssh/ssh_config ssh远程登录\nssh-keygen ssh-copy-id NAME@IP 添加口令: ssh-keygen -p ssh代理(不用自己再输入私钥密码)\nssh-agent bash ssh-add ","permalink":"https://tazegi.github.io/post/linux/ssh/","summary":"","title":"Ssh"},{"content":" awk 变量\n分隔符: FS (field separator) 记录分隔符: RS (record separator) 字段数: NF (number of field) 行号: NR (number of record) FNR: 各文件分别计数 FILENAME: 当前文件名 ARGC: 命令行参数个数\nawk \u0026#39;{print ARGC}\u0026#39; /etc/issue /etc/os-release 取出访问量最多的前几个ip地址\nawk \u0026#39;{print $1}\u0026#39; nginx.access.log-20200428 |sort |uniq -c |sort -nr |head -3 取出分区利用率\n\\df |grep \u0026#39;^/dev\u0026#39; |awk -F\u0026#39;[[:space:]​]+|%\u0026#39; \u0026#39;{print $1,$5}\u0026#39; \\df |awk -F\u0026#39;[[:space:]​]+|%\u0026#39; \u0026#39;/^\\/dev/{print $1,$5}\u0026#39; 取出ip地址\nifconfig wlan0 |awk \u0026#39;/netmask/{print $2}\u0026#39; ifconfig wlan0 |sed -rn \u0026#39;2s/^[^0-9]+([0-9.]+) .*$/\\1/p\u0026#39; 连接数最多的3个ip\nss -nt |awk -F\u0026#34; +|:\u0026#34; \u0026#39;/^ESTAB/{print $6}\u0026#39; |sort |uniq -c |sort -nr |head -n3 ","permalink":"https://tazegi.github.io/post/linux/awk/","summary":"","title":"Awk"},{"content":" def add(x,y=5): print(x,y) return x+y newadd=partial(add,4) newadd(6),newadd(7) #+RESULTS:\n","permalink":"https://tazegi.github.io/post/python/%E5%81%8F%E5%87%BD%E6%95%B0/","summary":"对一个函数的部分参数固定,从而返回一个新包装函数,这个函数应该是关于剩余参数的一个函数","title":"偏函数"},{"content":" def triangle_print(n): for i in range(1,n+1): for j in range(n,0,-1): print(len(str(j))*\u0026#39; \u0026#39; if j\u0026gt;i else j,end=\u0026#39; \u0026#39;) print() triangle_print(12) 1 2 1 3 2 1 4 3 2 1 5 4 3 2 1 6 5 4 3 2 1 7 6 5 4 3 2 1 8 7 6 5 4 3 2 1 9 8 7 6 5 4 3 2 1 10 9 8 7 6 5 4 3 2 1 11 10 9 8 7 6 5 4 3 2 1 12 11 10 9 8 7 6 5 4 3 2 1 ","permalink":"https://tazegi.github.io/post/python/%E4%B8%8A%E4%B8%89%E8%A7%92%E6%89%93%E5%8D%B0/","summary":" def triangle_print(n): for i in range(1,n+1): for j in range(n,0,-1): print(len(str(j))*\u0026#39; \u0026#39; if j\u0026gt;i else j,end=\u0026#39; \u0026#39;) print() triangle_print(12) 1 2 1 3 2 1 4 3 2 1 5 4 3 2 1 6 5 4 3 2 1 7 6 5 4 3 2 1 8 7 6 5 4 3 2 1 9 8 7 6 5 4 3 2 1 10 9 8 7 6 5 4 3 2 1 11 10 9 8 7 6 5 4 3 2 1 12 11 10 9 8 7 6 5 4 3 2 1 ","title":"上三角打印"},{"content":"","permalink":"https://tazegi.github.io/post/python/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"re","title":"正则表达式"},{"content":" pickle\nimport pickle filename=\u0026#39;./ser.bin\u0026#39; a=99 with open(filename,\u0026#39;wb\u0026#39;) as f: pickle.dump(a,f) with open(filename,\u0026#39;rb\u0026#39;) as f: x=pickle.load(f) print(type(x),x) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; 99 json\nimport json d={\u0026#39;name\u0026#39;:\u0026#39;tom\u0026#39;,\u0026#39;age\u0026#39;:20,\u0026#39;interest\u0026#39;:[\u0026#39;movie\u0026#39;,\u0026#39;nusic\u0026#39;]} x=json.dumps(d) print(type(x),x) d1=json.loads(x) print(type(d1),d1) print(d==d1) # ==比较内容 print(d is d1) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; {\u0026#34;name\u0026#34;: \u0026#34;tom\u0026#34;, \u0026#34;age\u0026#34;: 20, \u0026#34;interest\u0026#34;: [\u0026#34;movie\u0026#34;, \u0026#34;nusic\u0026#34;]} \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; {\u0026#39;name\u0026#39;: \u0026#39;tom\u0026#39;, \u0026#39;age\u0026#39;: 20, \u0026#39;interest\u0026#39;: [\u0026#39;movie\u0026#39;, \u0026#39;nusic\u0026#39;]} True False ","permalink":"https://tazegi.github.io/post/python/%E5%BA%8F%E5%88%97%E5%8C%96/","summary":"pickle, json","title":"序列化"},{"content":" from shutil import copyfile,copyfileobj,copy,copy2,copytree import shutil from pathlib import Path dst=\u0026#39;/home/f/tdir\u0026#39; src=\u0026#39;/home/f/blog/hugo/content/post/Python\u0026#39; #复制文件夹 # copytree(src,dst) #删除复制的文件夹 shutil.rmtree(dst,True) def fn(x,names): print(x,names) s=set() for name in names: if name.endswith(\u0026#39;.org\u0026#39;): print(name) s.add(name) return s # return {name for name in names if name.endswith(\u0026#39;.org\u0026#39;)} # return set(filter(lambda name: name.endswith(\u0026#39;.py\u0026#39;), names)) # filter 是迭代器只能使用一次 copytree(src,dst,ignore=fn) #遍历文件夹,Path是列表,*是解构 print(*Path(dst).rglob(\u0026#39;*\u0026#39;),sep=\u0026#39;\\n\u0026#39;) /home/f/blog/hugo/content/post/Python [\u0026#39;环境安装.org\u0026#39;, \u0026#39;查看帮助.org\u0026#39;, \u0026#39;九九乘法表.org\u0026#39;, \u0026#39;练习.org\u0026#39;, \u0026#39;生成器函数.org\u0026#39;, \u0026#39;冒泡排序.org\u0026#39;, \u0026#39;递归函数.org\u0026#39;, \u0026#39;选择排序.org\u0026#39;, \u0026#39;装饰器.org\u0026#39;, \u0026#39;插入排序.org\u0026#39;, \u0026#39;递归.org\u0026#39;, \u0026#39;t.py\u0026#39;, \u0026#39;shutil模块的使用.org\u0026#39;] 环境安装.org 查看帮助.org 九九乘法表.org 练习.org 生成器函数.org 冒泡排序.org 递归函数.org 选择排序.org 装饰器.org 插入排序.org 递归.org shutil模块的使用.org /home/f/tdir/t.py ","permalink":"https://tazegi.github.io/post/python/shutil%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"复制删除文件夹","title":"Shutil模块的使用"},{"content":" 循环\ndef factorial1(n): s=1 for i in range(2,n+1): s*=i return s def factorial2(n): s=1 for i in range(n,1,-1): s*=i return s print(factorial1(5)) print(factorial2(5)) 120 120 递归\ndef factorial(n): if n==1: return 1 return n*factorial(n-1) print(factorial(5)) 120 def factorial(n,s=1): if n==1: return s return factorial(n-1,s*n) print(factorial(5)) 120 ","permalink":"https://tazegi.github.io/post/python/%E9%80%92%E5%BD%92/","summary":"阶乘","title":"递归"},{"content":" nums = [1, 9, 8, 5, 6] nums = [None]+nums length = len(nums) for i in range(2, length): nums[0] = nums[i] j = i-1 if nums[j] \u0026gt; nums[0]: while nums[j] \u0026gt; nums[0]: nums[j+1] = nums[j] j -= 1 nums[j+1] = nums[0] print(nums[1:]) [1, 5, 6, 8, 9] ","permalink":"https://tazegi.github.io/post/python/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","summary":"将待排序数插入到已经排好的有序区的合适位置","title":"插入排序"},{"content":" from functools import update_wrapper,wraps def logger(wrapped): @wraps(wrapped) # wrapper=wraps(logger)(wrapper) def wrapper(*args,**kwargs): \u0026#34;wrapper\u0026#34; print(\u0026#39;执行前可以做的事情,增强\u0026#39;,wrapped.__name__,args,kwargs) ret=wrapped(*args,**kwargs) print(\u0026#39;执行后可以做的事情,增强\u0026#39;) return ret # update_wrapper(wrapped,wrapper) return wrapper @logger #等价于 add=logger(add) def add(x,y): \u0026#34;add\u0026#34; return x+y print(add(4,5)) print(add.__name__,add.__doc__) 执行前可以做的事情,增强 add (4, 5) {} 执行后可以做的事情,增强 9 add add ","permalink":"https://tazegi.github.io/post/python/%E8%A3%85%E9%A5%B0%E5%99%A8/","summary":"装的一模一样","title":"装饰器"},{"content":" 简单的选择排序\nnums=[1,9,8,5] print(nums) length=len(nums) for i in range(length-1): maxindex=i for j in range(i+1,length): if nums[j]\u0026gt;nums[maxindex]: maxindex=j nums[i],nums[maxindex]=nums[maxindex],nums[i] print(nums) # if i==0:break [1, 9, 8, 5] [9, 1, 8, 5] [9, 8, 1, 5] [9, 8, 5, 1] 变种: 二元选择排序\nnums_list=[[1,9,8,5],[9,8,7,5,3,1,4,6,2],[1,1,1,1,1,1,1,1]] nums=nums_list[2] print(nums) length=len(nums) for i in range(length//2): maxindex=i minindex=-i-1 minorigin=minindex for j in range(i+1,length-1): if nums[j]\u0026gt;nums[maxindex]: maxindex=j if nums[minindex]\u0026gt;nums[-j-1]: minindex=-j-1 #负索引 print(maxindex,minindex) if nums[maxindex]==nums[minindex]: break if i!=maxindex: nums[i],nums[maxindex]=nums[maxindex],nums[i] if i==minindex or i==length+minindex: minindex=maxindex-length if minorigin!=minindex and nums[minindex] != nums[minorigin]: nums[minorigin],nums[minindex]=nums[minindex],nums[minorigin] print(nums) # break [1, 1, 1, 1, 1, 1, 1, 1] 0 -1 ","permalink":"https://tazegi.github.io/post/python/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","summary":"找极值,放入一端","title":"选择排序"},{"content":" def fib1(n): a=b=1 for i in range(n-2): a,b=b,a+b print(b) fib1(10) 2 3 5 8 13 21 34 55 def fib3(n,a=1,b=1): if n\u0026lt;3: return b a,b=b,a+b print(b) return fib3(n-1,a,b) fib3(10) 2 3 5 8 13 21 34 55 ","permalink":"https://tazegi.github.io/post/python/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/","summary":"函数调用次数替代循环次数","title":"递归函数"},{"content":" nums=[3,1,2,-1] length=len(nums) for i in range(length-1): swapped=False for j in range(length-1-i): if nums[j]\u0026gt;nums[j+1]: nums[j],nums[j+1]=nums[j+1],nums[j] swapped=True if not swapped: break print(nums) [-1, 1, 2, 3] ","permalink":"https://tazegi.github.io/post/python/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","summary":"两两比较,大的往后推","title":"冒泡排序"},{"content":" def fib(): a=0 b=1 while True: yield b a,b=b,a+b f=fib() for i in range(1,102): print(i,next(f)) 1 1 2 1 3 2 4 3 5 5 6 8 7 13 8 21 9 34 10 55 11 89 12 144 13 233 14 377 15 610 16 987 17 1597 18 2584 19 4181 20 6765 21 10946 22 17711 23 28657 24 46368 25 75025 26 121393 27 196418 28 317811 29 514229 30 832040 31 1346269 32 2178309 33 3524578 34 5702887 35 9227465 36 14930352 37 24157817 38 39088169 39 63245986 40 102334155 41 165580141 42 267914296 43 433494437 44 701408733 45 1134903170 46 1836311903 47 2971215073 48 4807526976 49 7778742049 50 12586269025 51 20365011074 52 32951280099 53 53316291173 54 86267571272 55 139583862445 56 225851433717 57 365435296162 58 591286729879 59 956722026041 60 1548008755920 61 2504730781961 62 4052739537881 63 6557470319842 64 10610209857723 65 17167680177565 66 27777890035288 67 44945570212853 68 72723460248141 69 117669030460994 70 190392490709135 71 308061521170129 72 498454011879264 73 806515533049393 74 1304969544928657 75 2111485077978050 76 3416454622906707 77 5527939700884757 78 8944394323791464 79 14472334024676221 80 23416728348467685 81 37889062373143906 82 61305790721611591 83 99194853094755497 84 160500643816367088 85 259695496911122585 86 420196140727489673 87 679891637638612258 88 1100087778366101931 89 1779979416004714189 90 2880067194370816120 91 4660046610375530309 92 7540113804746346429 93 12200160415121876738 94 19740274219868223167 95 31940434634990099905 96 51680708854858323072 97 83621143489848422977 98 135301852344706746049 99 218922995834555169026 100 354224848179261915075 101 573147844013817084101 ","permalink":"https://tazegi.github.io/post/python/%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0/","summary":"斐波那契数列","title":"生成器函数"},{"content":" 斐波那契数列,打印第30项\na=0 b=1 count=1 print(count,b) while True: count+=1 if count\u0026gt;30: break a,b=b,a+b print(count,b) 1 1 2 1 3 2 4 3 5 5 6 8 7 13 8 21 9 34 10 55 11 89 12 144 13 233 14 377 15 610 16 987 17 1597 18 2584 19 4181 20 6765 21 10946 22 17711 23 28657 24 46368 25 75025 26 121393 27 196418 28 317811 29 514229 30 832040 打印菱形\nn=7 e=n//2 for i in range(-e,e+1): print(\u0026#39; \u0026#39;*abs(i),\u0026#39;*\u0026#39;*(n-2*abs(i)),sep=\u0026#39;\u0026#39;) * *** ***** ******* ***** *** * ","permalink":"https://tazegi.github.io/post/python/%E7%BB%83%E4%B9%A0/","summary":"斐波那契数列,打印菱形","title":"练习"},{"content":" for i in range(1,10): for j in range(1,i+1): print(\u0026#39;{}*{}={:\u0026lt;{}}\u0026#39;.format(j,i,i*j,2 if j==1 else 3),end=\u0026#39;\\n\u0026#39; if i==j else \u0026#34;\u0026#34;) 1*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 1*5=5 2*5=10 3*5=15 4*5=20 5*5=25 1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 行结束符的使用 ","permalink":"https://tazegi.github.io/post/python/%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8/","summary":" for i in range(1,10): for j in range(1,i+1): print(\u0026#39;{}*{}={:\u0026lt;{}}\u0026#39;.format(j,i,i*j,2 if j==1 else 3),end=\u0026#39;\\n\u0026#39; if i==j else \u0026#34;\u0026#34;) 1*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 1*5=5 2*5=10 3*5=15 4*5=20 5*5=25 1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 行结束符的使用 ","title":"九九乘法表"},{"content":" 查看帮助 pydoc\nvj python-docs pydoc -p 80 help(int) int* ipython中 /usr/share/doc/python-docs-3.11.1/html/index.html ","permalink":"https://tazegi.github.io/post/python/%E6%9F%A5%E7%9C%8B%E5%B8%AE%E5%8A%A9/","summary":" 查看帮助 pydoc\nvj python-docs pydoc -p 80 help(int) int* ipython中 /usr/share/doc/python-docs-3.11.1/html/index.html ","title":"查看帮助"},{"content":" 环境安装 virtualenv #切换版本 alternatives --config python3 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple pip install virtualenv --user echo $PATH mkdir ~/venvs mkdir -p ~/projects/cmdb cd venvs virtualenv vcmdb #进入 . venvs/vcmdb/bin/activate #退出 deactivate python装在~/venvs/vcmdb\npyenv yum install git gcc make patch gdbm-devel openssl-devel curl sqlite-devel readline-devel zlig-devel bzip2-devel -y proxychains curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash .bashrc\nexport PATH=\u0026#34;$HOME/.pyenv/bin:$PATH\u0026#34; eval \u0026#34;$(pyenv init --path)\u0026#34; eval \u0026#34;$(pyenv virtualenv-init -)\u0026#34; .bash_profile\n➜ ~ pyenv init # Load pyenv automatically by appending # the following to #~/.zprofile (for login shells) #and ~/.zshrc (for interactive shells) : export PYENV_ROOT=\u0026#34;$HOME/.pyenv\u0026#34; command -v pyenv \u0026gt;/dev/null || export PATH=\u0026#34;$PYENV_ROOT/bin:$PATH\u0026#34; eval \u0026#34;$(pyenv init -)\u0026#34; # Restart your shell for the changes to take effect. 安装cpython\npyenv install -l pyenv install -v 3.9.9 安装失败\nmkdir .pyenv/cache #移动Python-3.6.9.tar.xz到cache文件夹 pyenv install -v 3.9.9 -vvv 选择项目使用的python版本\ncd project/cmdb pyenv local 3.9.9 使用内置virtualenv\npyenv virtualenv 3.9.9 v399 pyenv local v399 python装在.pyenv/versions/3.9.9/envs/v399/\n常用命令 #更新仓库 pyenv update #查看所有版本 pyenv versions #查看当前版本 pyenv version jupyter jupyter信赖ipython,装完jupyter,ipython就可以用了\npip install jupyter --user jupyter notebook ll Untitled.ipynb 快捷键\nl 行号 a b 插入 tab 补全 _ 上次返回的结果 __ 上上次返回的结果 ","permalink":"https://tazegi.github.io/post/python/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","summary":"环境安装 virtualenv #切换版本 alternatives --config python3 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple pip install virtualenv --user echo $PATH mkdir ~/venvs mkdir -p ~/projects/cmdb cd venvs virtualenv vcmdb #进入 . venvs/vcmdb/bin/activate #退出 deactivate python装在~/venvs/vcmdb\npyenv yum install git gcc make patch gdbm-devel openssl-devel curl sqlite-devel readline-devel zlig-devel bzip2-devel -y proxychains curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash .bashrc\nexport PATH=\u0026#34;$HOME/.pyenv/bin:$PATH\u0026#34; eval \u0026#34;$(pyenv init --path)\u0026#34; eval \u0026#34;$(pyenv virtualenv-init -)\u0026#34; .bash_profile\n➜ ~ pyenv init # Load pyenv automatically by appending # the following to #~/.","title":"环境安装"},{"content":" 内核参数优化 临时修改: sysctl -w parameter=VALUE ping: /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts 读取: s sysctl -p /etc/sysctl.d/foo.conf 模块 卸载: modprobe -r MODULE 同 rmmod 加装: modprobe MODULE\n加载根据文件路径: insmod 文件路径\nmodinfo -n 模块 insmod 不能解决信赖 加载uas之前心须加载usb_storage,因为uas信赖usb_storage 如果先加载uas会报错 centos编译内核 配置\ncd /usr/src/linux cp /boot/config-`uname -r` .config 根据当前系统内核配置文件来配置内核 可选\n将 CONFIG_SYSTEM_TRUSTED_KEYS 的值设为空 注释 CONFIG_MODULE_SIG=y make menuconfig\nGeneral setup ---\u0026gt; Local version - append to kernel release 输入\u0026#34;-evil-0.0.1\u0026#34; 编译: make -j 13 安装\nmake modules_install make install 卸载内核\n删除 /usr/src/linux 目录下不需要的内核源码 删除 /lib/modules 目录下不需要的内核库文件 删除 /boot 目录下启动的内核和内核映像文件 清理\n#会保留.config文件 make clean #会清理.config文件 make mrproper #包含make mrproper,并清理patches以及编辑器备份文件 make distclean ","permalink":"https://tazegi.github.io/post/linux/%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/","summary":"内核参数优化 临时修改: sysctl -w parameter=VALUE ping: /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts 读取: s sysctl -p /etc/sysctl.d/foo.conf 模块 卸载: modprobe -r MODULE 同 rmmod 加装: modprobe MODULE\n加载根据文件路径: insmod 文件路径\nmodinfo -n 模块 insmod 不能解决信赖 加载uas之前心须加载usb_storage,因为uas信赖usb_storage 如果先加载uas会报错 centos编译内核 配置\ncd /usr/src/linux cp /boot/config-`uname -r` .config 根据当前系统内核配置文件来配置内核 可选\n将 CONFIG_SYSTEM_TRUSTED_KEYS 的值设为空 注释 CONFIG_MODULE_SIG=y make menuconfig\nGeneral setup ---\u0026gt; Local version - append to kernel release 输入\u0026#34;-evil-0.0.1\u0026#34; 编译: make -j 13 安装\nmake modules_install make install 卸载内核","title":"内核参数优化"},{"content":" 进程 查看进程编号: pidof firefox\nprtstat `pidof X` 详细 prtstat 1 判断多线程: pstree -p 是否含有花括号\ncat /proc/`pidof xfce4-panel`/status 查看进程状态码: man ps /CODES 查看信号\nman 7 signal #zsh无效 trap -l 创建管道文件: mkfifo /data/test.fifo ps auf 显示进程关系 k 排序\n# -%cpu表示降序 ps ao pid,%cpu,%mem,cmd k -%cpu ps au k -%cpu ps au k %cpu 优先级 设置\n#zsh无效 s nice -n -10 ping baidu.com ➜ ~ ps ao pid,cmd,nice |grep ping 8959 sudo nice -n -10 ping baidu 0 8960 ping baidu.com -10 修改\n➜ ~ s renice -n -20 30221 30221 (process ID) old priority 0, new priority -20 ➜ ~ ps ao pid,cmd,nice |grep firefox 30221 /usr/lib64/firefox/firefox -20 cpu的绑定: taskset --help pgrep pgrep -au f #查看子进程 pgrep -aP PID pgrep -at pts/1 mpstat,iostat dstat vmstat #安装: vj sysstat dstat #每2秒执行1次,6次后退出 mpstat 2 6 vmstat 1 top,iotop,iftop 排序: M(mem) P(cpu) T(累积占据CPU时长) 1:显示每个cpu s:delay k:kill pmap 查看程序占用的内存空间\n➜ ~ s pmap 1 1: init [3] 000055e6aeb70000 12K r---- init 000055e6aeb73000 28K r-x-- init 000055e6aeb7a000 8K r---- init 000055e6aeb7c000 4K r---- init 000055e6aeb7d000 4K rw--- init 000055e6afb2b000 132K rw--- [ anon ] 00007f150ffff000 12K rw--- [ anon ] 00007f1510002000 136K r---- libc.so.6 00007f1510024000 1328K r-x-- libc.so.6 00007f1510170000 332K r---- libc.so.6 00007f15101c3000 16K r---- libc.so.6 00007f15101c7000 8K rw--- libc.so.6 00007f15101c9000 32K rw--- [ anon ] 00007f15101e2000 8K rw--- [ anon ] 00007f15101e4000 4K r---- ld-linux-x86-64.so.2 00007f15101e5000 148K r-x-- ld-linux-x86-64.so.2 00007f151020a000 40K r---- ld-linux-x86-64.so.2 00007f1510215000 8K r---- ld-linux-x86-64.so.2 00007f1510217000 8K rw--- ld-linux-x86-64.so.2 00007ffd4573a000 132K rw--- [ stack ] 00007ffd45779000 16K r---- [ anon ] 00007ffd4577d000 8K r-x-- [ anon ] ffffffffff600000 4K r-x-- [ anon ] total 2428K strace ltrace 查看程序运行过程中的系统调用\n#安装 vp strace ltrace strace ls #显示库(语言库)的调用 ltrace ls nload nload wlan1 wlan0 glances glances -s glances -c IP lsof(list open file) lsof -i :PORT #tty gentoo无效 lsof /dev/pts/2 lsof -p PID 并行运行 方法1\ncat all.sh fi.sh\u0026amp; f2.sh\u0026amp; f3.sh\u0026amp; 方法2\n(f1.sh\u0026amp;);(f2.sh\u0026amp;);(f3.sh\u0026amp;); 方法3\nf1.sh\u0026amp; f2.sh\u0026amp; f3.sh\u0026amp; 计划任务 at\nat 14:45 at -l #同atq at -c 3 at -d 3 #同atrm 白名单: /etc/at.allow 黑名单: /etc/at.deny ","permalink":"https://tazegi.github.io/post/linux/%E8%BF%9B%E7%A8%8B/","summary":"进程 查看进程编号: pidof firefox\nprtstat `pidof X` 详细 prtstat 1 判断多线程: pstree -p 是否含有花括号\ncat /proc/`pidof xfce4-panel`/status 查看进程状态码: man ps /CODES 查看信号\nman 7 signal #zsh无效 trap -l 创建管道文件: mkfifo /data/test.fifo ps auf 显示进程关系 k 排序\n# -%cpu表示降序 ps ao pid,%cpu,%mem,cmd k -%cpu ps au k -%cpu ps au k %cpu 优先级 设置\n#zsh无效 s nice -n -10 ping baidu.com ➜ ~ ps ao pid,cmd,nice |grep ping 8959 sudo nice -n -10 ping baidu 0 8960 ping baidu.","title":"进程"},{"content":" 网络 客户端随机使用端口,范围定义: /proc/sys/net/ipv4/ip_local_port_range 查看程序占用的端口\nss -ntlp lsof -i :22 孤儿连接: 在发第二个分手包时,服务器崩溃,客户端处于孤儿连接状态\n# 指定孤儿连接数目 ➜ ~ cat /proc/sys/net/ipv4/tcp_max_orphans 65536 # 指定孤儿连接生存时间 ➜ ~ cat /proc/sys/net/ipv4/tcp_fin_timeout 60 半连接\n#半连接 ➜ ~ cat /proc/sys/net/ipv4/tcp_max_syn_backlog 1024 #全连接 ➜ ~ cat /proc/sys/net/core/somaxconn 4096 ip addr 增加1个ip地址 s ip address add 192.168.10.100 dev wlan0 label wlan1:2 删除1个ip地址 s ip address del 192.168.10.100/32 dev wlan0 route 两个连接相同交换机的不同ip ping 通\ns ip route add default dev wlan0 删除: s ip route del default dev wlan0 scope link 删除默认路由: s ip route del default via 192.168.10.1 添加默认路由: s ip route add default via 192.168.10.1 给回环网络加上地址 ➜ ~ s ip addr a 1.1.1.1/24 dev lo label lo:1 ➜ ~ ip a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 brd 127.255.255.255 scope host lo valid_lft forever preferred_lft forever inet 1.1.1.1/24 scope global lo:1 valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever ➜ ~ ping 1.1.1.100 PING 1.1.1.100 (1.1.1.100) 56(84) bytes of data. 64 bytes from 1.1.1.100: icmp_seq=1 ttl=64 time=0.025 ms 64 bytes from 1.1.1.100: icmp_seq=2 ttl=64 time=0.049 ms 64 bytes from 1.1.1.100: icmp_seq=3 ttl=64 time=0.041 ms ss 查看监听: ss -ntl 查看打开的所有端口: ss -nta 判断端口号是否打开\n\u0026lt; /dev/tcp/127.0.0.1/2017 zsh无效 ss -ntl |grep \u0026#34;:80\\\u0026gt;\u0026#34; 条件\n➜ ~ ss -o state LISTENING \u0026#39;( dport = :2017 or sport = :2017 )\u0026#39; Netid Recv-Q Send-Q Local Address:Port Peer Address:Port Process tcp 0 4096 *:2017 *:* dport: 目标端口 sport: 源端口 ","permalink":"https://tazegi.github.io/post/linux/%E7%BD%91%E7%BB%9C/","summary":"网络 客户端随机使用端口,范围定义: /proc/sys/net/ipv4/ip_local_port_range 查看程序占用的端口\nss -ntlp lsof -i :22 孤儿连接: 在发第二个分手包时,服务器崩溃,客户端处于孤儿连接状态\n# 指定孤儿连接数目 ➜ ~ cat /proc/sys/net/ipv4/tcp_max_orphans 65536 # 指定孤儿连接生存时间 ➜ ~ cat /proc/sys/net/ipv4/tcp_fin_timeout 60 半连接\n#半连接 ➜ ~ cat /proc/sys/net/ipv4/tcp_max_syn_backlog 1024 #全连接 ➜ ~ cat /proc/sys/net/core/somaxconn 4096 ip addr 增加1个ip地址 s ip address add 192.168.10.100 dev wlan0 label wlan1:2 删除1个ip地址 s ip address del 192.168.10.100/32 dev wlan0 route 两个连接相同交换机的不同ip ping 通\ns ip route add default dev wlan0 删除: s ip route del default dev wlan0 scope link 删除默认路由: s ip route del default via 192.","title":"网络"},{"content":" 磁盘 前言 创建设备文件\n➜ ~ ll /dev/nvme0n1p1 brw-rw---- 1 root disk 259, 1 Jan 15 19:57 /dev/nvme0n1p1 ➜ ~ s mknod nvme1 b 259 1 ➜ ~ ll nvme1 brw-r--r-- 1 root root 259, 1 Jan 15 22:27 nvme1 ➜ ~ s mount nvme1 /mnt ➜ ~ ll /mnt total 8.0K drwxr-xr-x 6 root root 4.0K Nov 1 06:43 EFI drwxr-xr-x 2 root root 4.0K Jan 12 13:24 \u0026#39;System Volume Information\u0026#39; 创建zero\n➜ ~ ll /dev/zero crw-rw-rw- 1 root root 1, 5 Jan 15 19:57 /dev/zero ➜ ~ s mknod zero c 1 5 ➜ ~ ll zero crw-r--r-- 1 root root 1, 5 Jan 15 22:35 zero 测试写硬盘速度\n➜ ~ s dd if=/dev/zero of=f1.img bs=1M count=1024 conv=fdatasync 1024+0 records in 1024+0 records out 1073741824 bytes (1.1 GB, 1.0 GiB) copied, 0.316082 s, 3.4 GB/s ➜ ~ s dd if=/dev/zero of=f1.img bs=1M count=16384 conv=fdatasync 16384+0 records in 16384+0 records out 17179869184 bytes (17 GB, 16 GiB) copied, 4.44352 s, 3.9 GB/s 测试读硬盘速度: s dd if=/dev/nvme0n1 of=/dev/null bs=1M count=1024 扫描磁盘\nalias scandisk=\u0026#34;eecho - - - \u0026gt; /sys/class/scsi_host/host0/scan;echo - - - \u0026gt; /sys/class/scsi_host/host1/scan;echo - - - \u0026gt; /sys/class/scsi_host/host2/scan;\u0026#34; 备份还原分区表\n#备份 dd if=/dev/sda of=/data/dpt.img bs=1 count=64 skip=446 hexdump -C /data/dpt.img scp /data/dpt.img 10.0.0.7:/data #破坏 dd if=/dev/zero of=/dev/sda bs=1 count=64 seek=446 hexdump -C -n 512 /dev/sda -v fdisk -l /dev/sda #还原 ip a a 10.0.0.8/24 dev ens33 ping 10.0.0.7 scp 10.0.0.7:/data/dpt.img . dd if=dpt.img of=/dev/sda bs=1 seek=446 查看磁盘类型:\n➜ ~ lsblk -d -o NAME,ROTA NAME ROTA nvme0n1 0 parted分区 查看: parted /dev/sdb 从1M到200M: parted /dev/sdb mkpart primary 1 200 删除第1个分区: parted /dev/sdb rm 1 清除分区信息: dd if=/dev/zero of=/dev/sdb bs=1 count=66 seek=446 64字节是分区信息,2字节是5a标记位 同步分区: partprobe\ncentos6\n#新增分区用 partx -a /dev/DEVICE partx -a /dev/DEVICE -f: force #删除分区用 partx -d --nr M-N /dev/DEVICE #示例: partx -d --nr 6-8 /dev/sda 文件系统 查看: ls /lib/modules/`uname -r`/kernel/fs lsblk -f 修复: fsck.ext4 一定不要在挂载状态下执行命令修复 只读挂载: mount -r LABEL=test /mnt/sdb2\n查看: cat /proc/mounts 重新挂载: mount -o remount.rw /mnt/sdb2 查看挂载点被哪个进程使用: fuser -v 挂载点\n全杀: fuser -km 挂载点 mount -U UUID 同 mount UUID= 挂载文件夹: mount -B ​/etc/ ​/mnt/etc/ -B –bind 用 mount 查看 fstab挂载文件\n#/etc/fstab /etc/ /mnt/etc/ none bind 0 0 挂载文件 dd if=/dev/zero of=/disk.img bs=1M count=100 mkfs.ext4 /disk.img blkid /disk.img mkdir /mnt/disk;mount /disk.img /mnt/disk 挂载文件系统自动分配loop设备 查看loop设备: losetup -a fstab挂载文件 #/etc/fstab /disk.img /data/disk xfs defaults 0 0 swap /proc/sys/vm/swappiness 的值决定了当内存战胜达到一定百分比时,会启用swap分区的空间 越高越倾向使用swap,可以设为0这样做并不会禁止对swap的使用,只是最大限度地降低了使用swap的可能性 制作swap fdisk /dev/sdc t: 选择类型 选择82 gentoo为43 mkswap /dev/sdc1 fstab: UUID= swap swap defaults 0 0 查看: swapon -s 挂载: swapon -a 修改swap优先级\n机械硬盘数字靠前的速度快,sdc1比sda5速度快 更改: 挂载选项: pri=10 swapoff /dev/sdc1 swapon -a 不分区制作swap\ndd if=/dev/zero of=/dev/sdc bs=1 count=66 seek=446 #mbr磁盘可用这种方法清理分区 mkswap /dev/sdc swapon /dev/sdc 文件制作swap dd if=/dev/zero of=/swapfile bs=1M count=1024 mkswap /swapfile fstab: /swapfile swap swap defaults 0 0 swapon -a 光盘 光盘制作iso: cp /dev/sr0 /data/centos8.iso\nmkisofs -r -o /root/etc.iso /etc\n来自genisoimage包 lvm lvcreate -n lv1 -l *100%vg* vg0 lvextend -l +100%free /dev/mapper/vg1-lv1\ns lvresize -L 30G /dev/mapper/vg1-lv1 lvextend -r -l +100%free /dev/mapper/vg1-lv1\n-r 既扩展空间又扩展文件系统 同步文件系统\next4: resize2fs /dev/vg/lv btrfs: s btrfs filesystem resize max / xfs: xfs_growfs / 缩减逻辑卷 缩减有数据损坏的风险,建议先备份再缩减\numount /dev/VG_NAME/LV_NAME fsck -f /dev/VG_NAME/LV_NAME resize2fs /dev/VG_NAME/LV_NAME #[mMgGtT] lvreduce -L [-]#[mMgGtT] /dev/VG_NAME/LV_NAME mount 跨主机迁移卷组(拆走硬盘,接到新电脑上) umount #禁用卷组 vgchange -a n vg0 #导出卷组 vgexport vg0 #导入卷组 vgimport vg0 #启用卷组 vgchange -ay vg0 mount 逻辑卷快照 s lvcreate -n gentoo-snapshot -s -L 100M /dev/mapper/system-gentoo #恢复快照 s lvconvert --merge /dev/mapper/system-gentoo--snapshot 更换硬盘的方法 #移动PV到同卷组其它成员 pvmove /dev/sdb1 vgreduce vg0 /dev/sdb1 pvremove /dev/sdb1 ","permalink":"https://tazegi.github.io/post/linux/%E7%A3%81%E7%9B%98/","summary":"磁盘 前言 创建设备文件\n➜ ~ ll /dev/nvme0n1p1 brw-rw---- 1 root disk 259, 1 Jan 15 19:57 /dev/nvme0n1p1 ➜ ~ s mknod nvme1 b 259 1 ➜ ~ ll nvme1 brw-r--r-- 1 root root 259, 1 Jan 15 22:27 nvme1 ➜ ~ s mount nvme1 /mnt ➜ ~ ll /mnt total 8.0K drwxr-xr-x 6 root root 4.0K Nov 1 06:43 EFI drwxr-xr-x 2 root root 4.0K Jan 12 13:24 \u0026#39;System Volume Information\u0026#39; 创建zero","title":"磁盘"},{"content":" sed 忽略大小写: sed -n \u0026#34;/ROOT/Ip\u0026#34; 取反: sed -n \u0026#34;/root/!p\u0026#34; 同 sed \u0026#34;/root/d\u0026#34; 修改并备份: sed -i.orig \u0026#34;/root/d\u0026#34; 替换: sed -i.bak \u0026#34;/^SELINUX=disabled/c SELINUX=enforcing\u0026#34; /etc/selinux/config 搜索替换 sed -Ei.bak \u0026#34;s/^(SELINUX=).*/\\1enforcing/\u0026#34; /etc/selinux/config grub\nsed -Ei.bak \u0026#39;/^GRUB_CMDLINE_LINUX/s/(.*)\u0026#34;$/\\1 net.ifnames=0\u0026#39; /etc/default/grub sed -nr \u0026#39;/^GRUB_CMDLINE/s/\u0026#34;$/ net.ifnames=0\u0026#34;/p\u0026#39; /etc/default/grub ip\nifconfig wlan0 |sed -rn \u0026#39;2s/^[^0-9]+([0-9.]+) .*$/\\1/p\u0026#39; 将没有搜索到的行加#\nsed -Ei.bak \u0026#39;/^#/!s/^/#/\u0026#39; /etc/fstab ","permalink":"https://tazegi.github.io/post/linux/sed/","summary":" sed 忽略大小写: sed -n \u0026#34;/ROOT/Ip\u0026#34; 取反: sed -n \u0026#34;/root/!p\u0026#34; 同 sed \u0026#34;/root/d\u0026#34; 修改并备份: sed -i.orig \u0026#34;/root/d\u0026#34; 替换: sed -i.bak \u0026#34;/^SELINUX=disabled/c SELINUX=enforcing\u0026#34; /etc/selinux/config 搜索替换 sed -Ei.bak \u0026#34;s/^(SELINUX=).*/\\1enforcing/\u0026#34; /etc/selinux/config grub\nsed -Ei.bak \u0026#39;/^GRUB_CMDLINE_LINUX/s/(.*)\u0026#34;$/\\1 net.ifnames=0\u0026#39; /etc/default/grub sed -nr \u0026#39;/^GRUB_CMDLINE/s/\u0026#34;$/ net.ifnames=0\u0026#34;/p\u0026#39; /etc/default/grub ip\nifconfig wlan0 |sed -rn \u0026#39;2s/^[^0-9]+([0-9.]+) .*$/\\1/p\u0026#39; 将没有搜索到的行加#\nsed -Ei.bak \u0026#39;/^#/!s/^/#/\u0026#39; /etc/fstab ","title":"Sed"},{"content":" 软件包 动态链接: 程序运行时会调用 静态链接: 把程序对应的信赖库复制一份到包 查询信赖库: ldd /bin/cat 查询已经加载的库: ldconfig -p rpm 利用cpio工具查看文件列表\nrpm2cpio bash-4.4.rpm | cpio -idv rpm -[i,e] 安装,卸载 v 显示详细过程 h 安装进度 rpm -q ncompress 查询包是否存在 rpm -qa *查询安装的所有包*\n模糊查询: rpm -qa |grep http 可选: rpm -qa \u0026#34;*http*​\u0026#34; *不带p的查询已安装的包*\nrpm -qi tree 查询已安装包的信息 rpm -ql tree 列出包包含的文件及放入的文件夹 带p的查询本地的包文件\nrpm -qpi rpm 包文件 查询 文件 中包的信息 rpm -qpl rpm 包文件 列出包包含的文件及放入的文件夹 *查询磁盘上的文件来自于哪个包*: rpm -qf /usr/bin/tree 查询哪个包提供了bash命令: rpm -q --whatprovides bash *查询bash命令信赖于哪些包*: rpm -q --whatrequires bash 查询配置文件: rpm -qc bash 查询程序的文档: rpm -qd bash 查询更新日志: rpm -q --changelog bash 查询包携带的脚本: rpm -q --scripts bash\nrpm -q --scripts httpd 密钥 查询包的密钥: rpm -K|--checksig rpmfile 导入: rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial 查询安装好的密钥: rpm -qa \u0026#34;gpg-pubkey*\u0026#34; 查询密钥的详细信息: rpm -qi gpg~ 校验包是否发生改变: rpm -v 包名 yum yum localinstall zabbix-server-mysql-4.4.7-1.el7.x86_64.rpm 列出仓库名: yum repolist [all,disable,enable] yum list available 列出未安装 临时启/禁用仓库: yum --enablerepo=ep* repolist 查询命令,文件来自于哪个包哪个仓库: yum [provides,whatprovides]\n查询命令来自于哪个包哪个仓库: yum [provides,whatprovides] yum-config-manager 查询文件来自于哪个包哪个仓库: yum [provides,whatprovides] /etc/vsftpd/vsftpd.conf 永久启/禁用仓库: yum-config-manager --disable epel 显示所有版本: yum [info,list] --showduplicates 安装时禁用某个仓库: yum install samba --disablerepo=updates *查看依赖的包*: yum deplist httpd yum历史 yum history yum history info 22 yum history undo 22 -y yum history redo 22 -y 系统救援 安装软件到/mnt/sysimage目录\nrpm -ivh /mnt/cdrom/Packages/rpm-4.11.3-40.e17.x86_64.rpm --root=/mnt/sysimage/\n# 卸载rpm rpm -e rpm --nodeps # 重启进入rescue模式 mkdir /mnt/cdrom mount /dev/sr0 /mnt/cdrom rpm -ivh /mnt/cdrom/Packages/rpm-4.11.3-40.e17.x86_64.rpm --root=/mnt/sysimage/ 清理缓存 /var/lib/rpm 包的元数据: 已安装包的信息\n/var/cache/yum/* 缓存文件夹 查询缓存占用: du -sh /var/cache/yum/x86_64/7/*\ngentoo: s du -sh /var/db/repos/* 清理缓存\nyum clean all 在配置文件存有时 yum和dnf失败最主要原因 yum的配置文件格式或路径错误 yum cache 网络不通 实现私用yum仓库 光盘 yum -y install httpd mkdir /var/www/html/centos/8 -pv mount /dev/sr0 /mnt/ cp -a /mnt/* /var/www/html/centos/8 systemctl enable --now httpd 网络 下载阿里云的extras源,制作私有yum源 dnf reposync --repoid=extras --download-metadate -p /var/www/html/centos/extras/ dpkg包管理器 列出已安装的包: dpkg -l 同 rpm -qa 显示该包的描述: dpkg -l 同 package 详细信息: dpkg -s package 同 rpm -qi 包含文件: dpkg -L package 同 rpm -ql 某个文件来自哪个包: dpkg -S /~ 同 rpm -qf 列出deb包的内容: dpkg -c package.deb 同 rpm -qpl 解包: dpkg --unpack package.deb ","permalink":"https://tazegi.github.io/post/linux/%E8%BD%AF%E4%BB%B6%E5%8C%85/","summary":"软件包 动态链接: 程序运行时会调用 静态链接: 把程序对应的信赖库复制一份到包 查询信赖库: ldd /bin/cat 查询已经加载的库: ldconfig -p rpm 利用cpio工具查看文件列表\nrpm2cpio bash-4.4.rpm | cpio -idv rpm -[i,e] 安装,卸载 v 显示详细过程 h 安装进度 rpm -q ncompress 查询包是否存在 rpm -qa *查询安装的所有包*\n模糊查询: rpm -qa |grep http 可选: rpm -qa \u0026#34;*http*​\u0026#34; *不带p的查询已安装的包*\nrpm -qi tree 查询已安装包的信息 rpm -ql tree 列出包包含的文件及放入的文件夹 带p的查询本地的包文件\nrpm -qpi rpm 包文件 查询 文件 中包的信息 rpm -qpl rpm 包文件 列出包包含的文件及放入的文件夹 *查询磁盘上的文件来自于哪个包*: rpm -qf /usr/bin/tree 查询哪个包提供了bash命令: rpm -q --whatprovides bash *查询bash命令信赖于哪些包*: rpm -q --whatrequires bash 查询配置文件: rpm -qc bash 查询程序的文档: rpm -qd bash 查询更新日志: rpm -q --changelog bash 查询包携带的脚本: rpm -q --scripts bash","title":"软件包"},{"content":" 压缩 对文件 compress 安装ncompress 比较\n➜ ~ ll emerge.txt w-r--r-- 1 f f 50K Dec 29 22:05 emerge.txt ➜ ~ compress emerge.txt ➜ ~ ll emerge.txt.Z w-r--r-- 1 f f 20K Dec 29 22:05 emerge.txt.Z gentoo没有 uncompress 命令\ncompress -d emerge.txt.Z #可选 zcat emerge.txt.Z \u0026gt; emerge.txt 选项\n-c 结果输出至标准输出,不删除原文件\n#压缩 compress -c emerge.txt \u0026gt; emerge.txt.Z #解压缩 compress -dc emerge.txt.Z \u0026gt; emerge2.txt -v 显示详情 文件预览: zcat emerge.txt.Z gzip,gunzip gzip emerge.txt gunzip emerge.txt.gz 比较gzip和compress\n➜ ~ ll emerge* -rw-r--r-- 1 f f 50K Jan 10 16:26 emerge2.txt -rw-r--r-- 1 f f 14K Dec 29 22:05 emerge.txt.gz -rw-r--r-- 1 f f 20K Jan 10 16:28 emerge.txt.Z 最高压缩比压缩\n➜ ~ gzip -9 emerge.txt ➜ ~ ll emerge* -rw-r--r-- 1 f f 50K Jan 10 16:26 emerge2.txt -rw-r--r-- 1 f f 14K Dec 29 22:05 emerge.txt.gz -rw-r--r-- 1 f f 20K Jan 10 16:28 emerge.txt.Z 对命令的输出进行压缩 : cat emerge.txt |gzip \u0026gt; emerge.txt.gz bzip2,bunzip2 选项 -k 保留原文件 比较\n➜ ~ bzip2 emerge.txt ➜ ~ ll emerge* -rw-r--r-- 1 f f 50K Jan 10 16:26 emerge2.txt -rw-r--r-- 1 f f 12K Dec 29 22:05 emerge.txt.bz2 -rw-r--r-- 1 f f 14K Jan 10 16:40 emerge.txt.gz -rw-r--r-- 1 f f 20K Jan 10 16:28 emerge.txt.Z 预览: bzcat emerge.txt.bz2 xz,unxz 比较\n➜ ~ xz -k emerge.txt ➜ ~ ll emerge* -rw-r--r-- 1 f f 50K Jan 10 16:26 emerge2.txt -rw-r--r-- 1 f f 50K Dec 29 22:05 emerge.txt -rw-r--r-- 1 f f 12K Dec 29 22:05 emerge.txt.bz2 -rw-r--r-- 1 f f 14K Jan 10 16:40 emerge.txt.gz -rw-r--r-- 1 f f 13K Dec 29 22:05 emerge.txt.xz -rw-r--r-- 1 f f 20K Jan 10 16:28 emerge.txt.Z 预览: xzcat emerge.txt.xz 文件夹 zip,unzip 可能丢失文件属性信息,一般建议使用tar zip -r target.zip source, -r 递归 指定目录解包,默认解压到当前目录: unzip target.zip -d / 不包含目录本身,只打包目录内的文件和子目录: zip -r ~.zip * 比较\n➜ ~ zip emerge.txt.zip emerge.txt adding: emerge.txt (deflated 72%) ➜ ~ ll emerge* -rw-r--r-- 1 f f 50K Jan 10 16:26 emerge2.txt -rw-r--r-- 1 f f 50K Dec 29 22:05 emerge.txt -rw-r--r-- 1 f f 12K Dec 29 22:05 emerge.txt.bz2 -rw-r--r-- 1 f f 14K Jan 10 16:40 emerge.txt.gz -rw-r--r-- 1 f f 13K Dec 29 22:05 emerge.txt.xz -rw-r--r-- 1 f f 20K Jan 10 16:28 emerge.txt.Z -rw-r--r-- 1 f f 14K Jan 10 17:16 emerge.txt.zip ➜ blog git:(master) ✗ unzip ../emerge.txt.zip Archive: ../emerge.txt.zip inflating: emerge.txt tar(Tape ARchive) c: 打包 t: 预览 x: 解包 打包\ntar cf target.tar sourcce 解包\n# -C指定目录 tar xf emerge.txt.tar -C Pictures 打包并压缩\nzcf gz jcf bz2 Jcf xz 选项\n-p 保留属性 无法保留acl权限,acl权限需要单独备份 -​-exclude -T 要打包的文件 -X不打包的文件\ntar zcvf mybackup.tgz -T /root/incledefilelist -X /root/excludefilelist 快速文件复制\ntar c /var |tar x -C /data/ 查看linux源代码行数 tar xvf linux.tar.xz du -sh linux cat `find -name \u0026#34;*.c\u0026#34;` |wc -l split 切割图片\n➜ Pictures split -b 10K 1048px-Heckert_GNU_white.svg.png pic ➜ Pictures ls 1048px-Heckert_GNU_white.svg.png picab picad picaf picah picaa picac picae picag picai -d 以数字为单位 合并图片\n➜ Pictures cat pic*\u0026gt; pic.png ➜ Pictures ll total 268K -rw-r--r-- 1 f f 83K Jan 9 13:48 1048px-Heckert_GNU_white.svg.png -rw-r--r-- 1 f f 10K Jan 10 23:08 picaa -rw-r--r-- 1 f f 10K Jan 10 23:08 picab -rw-r--r-- 1 f f 10K Jan 10 23:08 picac -rw-r--r-- 1 f f 10K Jan 10 23:08 picad -rw-r--r-- 1 f f 10K Jan 10 23:08 picae -rw-r--r-- 1 f f 10K Jan 10 23:08 picaf -rw-r--r-- 1 f f 10K Jan 10 23:08 picag -rw-r--r-- 1 f f 10K Jan 10 23:08 picah -rw-r--r-- 1 f f 2.4K Jan 10 23:08 picai -rw-r--r-- 1 f f 83K Jan 10 23:10 pic.png cpio #打包 find ./etc | cpio -ov \u0026gt; etc2.cpio #预览 cpio -tv \u0026lt; etc.cpio #解包 cpio -idv \u0026lt; /data/etc2.cpio ","permalink":"https://tazegi.github.io/post/linux/%E5%8E%8B%E7%BC%A9/","summary":"压缩 对文件 compress 安装ncompress 比较\n➜ ~ ll emerge.txt w-r--r-- 1 f f 50K Dec 29 22:05 emerge.txt ➜ ~ compress emerge.txt ➜ ~ ll emerge.txt.Z w-r--r-- 1 f f 20K Dec 29 22:05 emerge.txt.Z gentoo没有 uncompress 命令\ncompress -d emerge.txt.Z #可选 zcat emerge.txt.Z \u0026gt; emerge.txt 选项\n-c 结果输出至标准输出,不删除原文件\n#压缩 compress -c emerge.txt \u0026gt; emerge.txt.Z #解压缩 compress -dc emerge.txt.Z \u0026gt; emerge2.txt -v 显示详情 文件预览: zcat emerge.txt.Z gzip,gunzip gzip emerge.txt gunzip emerge.","title":"压缩"},{"content":" xargs 将输入传给下一个命令,作为其的参数 seq 10 |xargs 多行变1行, echo {1..10} |xargs -n1 1行变多g行\n➜ ~ seq 10 1 2 3 4 5 6 7 8 9 10 ➜ ~ seq 10 |xargs 1 2 3 4 5 6 7 8 9 10 ➜ ~ echo {1..10} 1 2 3 4 5 6 7 8 9 10 ➜ ~ echo {1..10} |xargs -n1 1 2 3 4 5 6 7 8 9 10 批量创建用户\necho user{1..10} |xargs -n1 useradd echo user{1..10} |xargs -n1 userdel -r getent passwd 结合ls find -maxdepth 1 -type f |xargs ls -Slh #不是那么好用 find -maxdepth 1 -type f -exec ls -Slh {} \\; 当文件存有空格\n➜ ~ touch \u0026#34;a b\u0026#34; ➜ ~ find -maxdepth 1 -type f |xargs ls -Slh ls: cannot access \u0026#39;./a\u0026#39;: No such file or directory ls: cannot access \u0026#39;b\u0026#39;: No such file or directory 因为xargs默认以空格作为分隔符 解决方法: 以空(nul)作为分隔符\n➜ ~ find -maxdepth 1 -type f -print0 | xargs -0 ls -Slh -rw-r--r-- 1 f f 0 Jan 10 15:37 \u0026#39;./a b\u0026#39; -0 代表空 ","permalink":"https://tazegi.github.io/post/linux/xargs/","summary":"xargs 将输入传给下一个命令,作为其的参数 seq 10 |xargs 多行变1行, echo {1..10} |xargs -n1 1行变多g行\n➜ ~ seq 10 1 2 3 4 5 6 7 8 9 10 ➜ ~ seq 10 |xargs 1 2 3 4 5 6 7 8 9 10 ➜ ~ echo {1..10} 1 2 3 4 5 6 7 8 9 10 ➜ ~ echo {1..10} |xargs -n1 1 2 3 4 5 6 7 8 9 10 批量创建用户","title":"Xargs"},{"content":" locate locate\n下载: vj mlocate updatedb\n➜ ~ locate passwd locate: can not stat () `/var/lib/mlocate/mlocate.db\u0026#39;: No such file or directory\n选项\n-i 不区分大小写 -n 只列举前n个项目 -r 使用基本正则表达式\nlocate -r \u0026#34;\\.conf$\u0026#34;\n使用正则匹配以.conf结尾的文件 \\. 转义正则.(任意一个字符) locate conf 匹配包含conf的文件 区配规则是模糊匹配 find 通配符要加双引号\n查找 指定搜索目录层级\n-maxdepth -mindepth\nfind /etc/ -maxdepth 2 -mindepth 2 对每个目录先处理目录内的文件,再处理目录本身\n-depth -d 根据文件名和inode查找\n-name -iname 不区分大小写 -inum 按inode号查找\nfind / -inum 256 -ls -samefile 相同inode的文件 -links 链接数为n的文件 -regex 匹配整个文件路径,而非文件名称\nfind / -regex \u0026#34;.*\\.jpg$\u0026#34; find / -nouser 查看没有所有者的文件 根据文件类型查找\ntype [bcdflsp] 查找空文件或目录\nfind / -type d -empty -ls find / -type f -empty -ls 组合条件 -a -o -not !\n默认取两结果的并集: find / -type d -empty -ls,同 find / -type d -a -empty -ls -o和-ls一起使用发生的问题\n➜ ~ s find /etc/ -type d -o -type l -ls |wc -l 372 ➜ ~ s find /etc/ -type d -o -type l |wc -l 532 #括号前后心须加空格 ➜ ~ s find /etc/ \\( -type d -o -type l \\) -ls |wc -l 532 s find /etc/ \\( -type d -o -type l \\) -ls |wc -l\n同 s find /etc/ \\( -type d -o -type l \\) -a -ls |wc -l -o或,-a并,或的优先级不如并且的优先级高 取反 find /etc ! -name \u0026#34;*.conf\u0026#34; 排除目录 \\( -path \u0026#34;/sys\u0026#34; -o -path \u0026#34;/proc\u0026#34; -o -path \u0026#34;/run\u0026#34; \\) -a -prune -o\nfind / \\( -path \u0026#34;/sys\u0026#34; -o -path \u0026#34;/proc\u0026#34; -o -path \u0026#34;/run\u0026#34; \\) -a -prune -o -type f -a -mmin -1 根据文件大小来查找\n-size [+,-]6k\n6k (5k,6k] -6k (0,5k] +6k (6k,] 根据时间戳\n-[a,m,c]time [+,-]# 以天为单位\n#​ [#,#+1] +# [#+1,] -# [0,#) [a,m,c]min [+,-]# 以分钟为单位 根据权限查找 -perm [/,-]\n什么都不加,精确匹配\nfind /etc -perm 600 权限必须是600 /,- 模糊匹配\n/:或 -:并\nfind /etc/ -perm /444, 只要有一个有读权限就可以 find /etc/ -perm -444, 三个都得有读权限 find /etc/ -perm -044, 0表示不关心 find / -perm [-,/]002 同\nfind ​/bin/ -perm [/,-]7000 -ls *不同 find /bin/ -perm /7000 -ls 只要1位有特殊权限就行 find / \\( -path \u0026#34;/sys\u0026#34; -o -path \u0026#34;/proc\u0026#34; \\) -a -prune -o -perm /002 -a -type f 查看其他人有没有写的权限 处理动作 -print 默认的处理动作 -ls\nfind -maxdepth 1 -type f |xargs ls -Slh #不是那么好用 find -maxdepth 1 -type f -exec ls -Slh {} \\; -fls 将查找到的所有文件的长格式信息保存至指定文件中,同-ls加重定向 -delete 慎用 -ok -exec 区别在于-ok会有交互\n#给当前目录的.sh文件加上可执行权限 find -maxdepth 1 -type f -perm 644 -name \u0026#34;*.sh\u0026#34; -exec chmod 755 {} \\; #调用的rm不是别名,慎用 find -maxdepth 1 -type f -perm 755 -name \u0026#34;.sh\u0026#34; -exec rm {} \\; #会有提示,输入y删除 find -maxdepth 1 -type f -perm 755 -name \u0026#34;.sh\u0026#34; -ok rm {} \\; ","permalink":"https://tazegi.github.io/post/linux/find/","summary":"locate locate\n下载: vj mlocate updatedb\n➜ ~ locate passwd locate: can not stat () `/var/lib/mlocate/mlocate.db\u0026#39;: No such file or directory\n选项\n-i 不区分大小写 -n 只列举前n个项目 -r 使用基本正则表达式\nlocate -r \u0026#34;\\.conf$\u0026#34;\n使用正则匹配以.conf结尾的文件 \\. 转义正则.(任意一个字符) locate conf 匹配包含conf的文件 区配规则是模糊匹配 find 通配符要加双引号\n查找 指定搜索目录层级\n-maxdepth -mindepth\nfind /etc/ -maxdepth 2 -mindepth 2 对每个目录先处理目录内的文件,再处理目录本身\n-depth -d 根据文件名和inode查找\n-name -iname 不区分大小写 -inum 按inode号查找\nfind / -inum 256 -ls -samefile 相同inode的文件 -links 链接数为n的文件 -regex 匹配整个文件路径,而非文件名称","title":"Find"},{"content":" {} 执行1组命令,不开启子进程 {}最后1个命令要加分号,花括号后面必须有空格,zsh不南要分号和空格 {}和()的区别\n#{} ➜ ~ name=evil520;{ echo $name;name=tang;echo $name; };echo $name evil520 tang tang ➜ ~ bash f@gentoo ~ $ name=evil520;{ echo $name;name=tang;echo $name; };echo $name evil520 tang tang #() ➜ ~ name=evil520;( echo $name;name=tang;echo $name; );echo $name evil520 tang evil520 ➜ ~ bash f@gentoo ~ $ name=evil520;( echo $name;name=tang;echo $name; );echo $name evil520 tang evil520 结论: 子进程的变量继承父进程,子进程对变量的修改不影响父进程 ​|后面的所有命令会开启子进程\n#zsh中管道不会开启子进程 ➜ ~ echo evil520 |read X;echo $X evil520 #切换到bash ➜ ~ bash evil520 #输出为空 f@gentoo ~/blog/hugo $ echo evil520 |read X;echo $X f@gentoo ~/blog/hugo $ echo evil520 | { read X;echo $X; } evil520 ","permalink":"https://tazegi.github.io/post/linux/%E5%AD%90%E8%BF%9B%E7%A8%8B/","summary":" {} 执行1组命令,不开启子进程 {}最后1个命令要加分号,花括号后面必须有空格,zsh不南要分号和空格 {}和()的区别\n#{} ➜ ~ name=evil520;{ echo $name;name=tang;echo $name; };echo $name evil520 tang tang ➜ ~ bash f@gentoo ~ $ name=evil520;{ echo $name;name=tang;echo $name; };echo $name evil520 tang tang #() ➜ ~ name=evil520;( echo $name;name=tang;echo $name; );echo $name evil520 tang evil520 ➜ ~ bash f@gentoo ~ $ name=evil520;( echo $name;name=tang;echo $name; );echo $name evil520 tang evil520 结论: 子进程的变量继承父进程,子进程对变量的修改不影响父进程 ​|后面的所有命令会开启子进程\n#zsh中管道不会开启子进程 ➜ ~ echo evil520 |read X;echo $X evil520 #切换到bash ➜ ~ bash evil520 #输出为空 f@gentoo ~/blog/hugo $ echo evil520 |read X;echo $X f@gentoo ~/blog/hugo $ echo evil520 | { read X;echo $X; } evil520 ","title":"子进程"},{"content":" test help test\n选项\n-v 判断变量是否定义,无法判断是否为空 -R 判断变量是否定义,或者为空 -L 判断文件是否为软链接, [ -L /lib ] -a -e 判断文件是否存有 []\n在比较字符串时,建议放在\u0026#34;\u0026#34;中 [ \u0026#34;$string\u0026#34; ] 字符串是否不空 [​[]]\n建议,当使用正则表达式或通配符使用,一般情况使用[] 与[]的区别\n比较字符串用 == 支持通配符 可以用正则表达式 =~ 结论\n#==右侧的*,想做为通配符,不要加\u0026#34;\u0026#34;,只想做为*,需要加\u0026#34;\u0026#34;或转义 [[ == * ]] case in yes,no脚本\nread -p \u0026#34;Do you agree(yes/no)?\u0026#34; INPUT case $INPUT in [Yy]|[Yy][Ee][Ss]) echo \u0026#34;You input is YES\u0026#34; ;; [Nn]|[Nn][On]) echo \u0026#34;You input is NO\u0026#34; ;; ,*) echo \u0026#34;Input false,please input yes or no!\u0026#34; esac while read while read WARNING=100 ss -nt |sed -En \u0026#39;/^ESTAB/s#.*[: ]([^:]+[0-9]):[0-9]+#\\1#p\u0026#39; |sort |uniq -c |while read count ip;do if [ $count -gt $WARNING ];then iptables -A INPUT -s $ip -j REJECT fi done select循环与菜单 help select\nselect与if语法一样\nselect variable in list; do done 用户输入的变量放入 REPLY 中 example\nPS3=\u0026#34;请输入菜的编号\u0026#34; select MENU in 鲍鱼 满汉全席 龙虾 燕窝 帝王蟹 退出;do case $REPLY in 1|3) echo \u0026#34;$MENU price is \\$10\u0026#34; ;; 2) echo \u0026#34;$MENU price is \\$1000\u0026#34; ;; 4|5) echo \u0026#34;$MENU price is \\$20\u0026#34; ;; 6) break ;; ,*) echo \u0026#34;点错了,没有这道菜\u0026#34; esac done ","permalink":"https://tazegi.github.io/post/linux/%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/","summary":"test help test\n选项\n-v 判断变量是否定义,无法判断是否为空 -R 判断变量是否定义,或者为空 -L 判断文件是否为软链接, [ -L /lib ] -a -e 判断文件是否存有 []\n在比较字符串时,建议放在\u0026#34;\u0026#34;中 [ \u0026#34;$string\u0026#34; ] 字符串是否不空 [​[]]\n建议,当使用正则表达式或通配符使用,一般情况使用[] 与[]的区别\n比较字符串用 == 支持通配符 可以用正则表达式 =~ 结论\n#==右侧的*,想做为通配符,不要加\u0026#34;\u0026#34;,只想做为*,需要加\u0026#34;\u0026#34;或转义 [[ == * ]] case in yes,no脚本\nread -p \u0026#34;Do you agree(yes/no)?\u0026#34; INPUT case $INPUT in [Yy]|[Yy][Ee][Ss]) echo \u0026#34;You input is YES\u0026#34; ;; [Nn]|[Nn][On]) echo \u0026#34;You input is NO\u0026#34; ;; ,*) echo \u0026#34;Input false,please input yes or no!","title":"条件判断"},{"content":" shell脚本 bash语法检查: bash -n\n调试: bash -x 脚本错误常见的有3种\n语法错误,会导致后续的命令不继续执行,可以用bash -n检查错误 命令错误,后续的命令还会继续执行,用bash -n无法检查出来,可以使用bash -x进行观察 逻辑错误,只能使用bash -x进行观察 $- 变量(bash有效)\nh: 打开选项后.shell会将命令所在的路径hash下来.通过 set +h 将h选项关闭 i: 当前shell是一个交互式的shell.在脚本中,i选项是关闭的 m: monitor,打开监控模式,就可以通过Job control来控制进程的停止,继续,后台或者前台执行等 B: braceexpand,大括号扩展 H: 可以通过!感叹号来调用历史命令 set\nset -o 查看选项 set -o errexit on 防止命令错误继续执行\nhelp set\nerrexit same as -e\n同 set -e ,遇到$?不为0就退出 true, echo $? 永远为真 false, echo $? 永远为假 set -u 防止使用未定义的变量\n-u – no-unset nounset same as -u\n同 set -o nounset 总结: set -ue set -x 当执行命令时,打印命令及其参数,类似bash -x shift用命令行参数实现批量创建用户\n#!/bin/bash PASS=evil520 while [ \u0026#34;$1\u0026#34; ];do useradd $1 \u0026amp;\u0026amp; echo $1 is created || echo $1 is exist echo $PASS | passwd --stdin $1 \u0026amp;\u0026gt; /dev/null shift done 信号捕捉\n查看: man 7 signal 定义信号触发器: trap \u0026#39;echo \u0026#34;Press ctrl+c\u0026#34;\u0026#39; int quit\n当触发2(C+c),3(C+\\)信号打印 trap \u0026#39;\u0026#39; int ,当触发2信号什么也不做 还原2信号的功能: trap \u0026#39;-\u0026#39; int trap 函数名 exit\n#退出时要执行的函数 trap ls exit ","permalink":"https://tazegi.github.io/post/linux/shell%E8%84%9A%E6%9C%AC/","summary":"shell脚本 bash语法检查: bash -n\n调试: bash -x 脚本错误常见的有3种\n语法错误,会导致后续的命令不继续执行,可以用bash -n检查错误 命令错误,后续的命令还会继续执行,用bash -n无法检查出来,可以使用bash -x进行观察 逻辑错误,只能使用bash -x进行观察 $- 变量(bash有效)\nh: 打开选项后.shell会将命令所在的路径hash下来.通过 set +h 将h选项关闭 i: 当前shell是一个交互式的shell.在脚本中,i选项是关闭的 m: monitor,打开监控模式,就可以通过Job control来控制进程的停止,继续,后台或者前台执行等 B: braceexpand,大括号扩展 H: 可以通过!感叹号来调用历史命令 set\nset -o 查看选项 set -o errexit on 防止命令错误继续执行\nhelp set\nerrexit same as -e\n同 set -e ,遇到$?不为0就退出 true, echo $? 永远为真 false, echo $? 永远为假 set -u 防止使用未定义的变量\n-u – no-unset nounset same as -u\n同 set -o nounset 总结: set -ue set -x 当执行命令时,打印命令及其参数,类似bash -x shift用命令行参数实现批量创建用户","title":"Shell脚本"},{"content":" 文本 vim 匹配行\n. 当前行 2,+5 $ set fileformat=[dos,unix]\nset ff set textwidth=65 xp c-w s c-w v c-w q c-w a ma `a` cat -A -E -n -b 非空行编号 tac rev nl 同 cat -b\ntail -[fn0,0f] 跟踪文件描述符 文件删除无法跟踪\ntail -F 跟踪文件名 cut #1,3,4,5 cut -d: -f1,3-5 /etc/passwd df|tr -s \u0026#34; \u0026#34; \u0026#34;%\u0026#34;|cut -d% -f5 paste paste 两个文件横向合并 paste -s -d: wc #过滤第1行 df|tail -n $(echo $(df|wc -l)-1|bc) sort sort -nt: -k3 /etc/passwd #倒序 sort -nrt: -k3 /etc/passwd uniq 删除前后相邻的重复行 -c count -d duplicate 仅显示重复的行 -u unique 仅显示不曾重复的行 查看连接的ip: ss -nt #去掉第1行 ss -nt|tail -n+2 ss -nt|tail -n+2|tr -s \u0026#34; \u0026#34; :|cut -d: -f6 |sort |uniq -c |sort -nr ss -nt |sed -En \u0026#39;/^ESTAB/s#.*[: ]([^:]+[0-9]):[0-9]+#\\1#p\u0026#39; |sort |uniq -c |sort -nr 比较二进制 cmp /bin/{dir,ls} hexdump -s 144640 -Cn 7 /bin/ls hexdump -s 144640 -Cn 7 /bin/dir grep #匹配1次停止 # -m match grep -m1 root /etc/passwd #或 grep -e root -e bash /etc/passwd #并 grep | grep #包含完整单词 # -w whole grep -w man 7 regex 排除空行和#开头的行\ngrep -v \u0026#34;^;\u0026#34; /etc/php/cli-php8.1/php.ini |grep -v ^$ grep -v \u0026#34;^;\\|^$\u0026#34; /etc/php/cli-php8.1/php.ini grep -v \u0026#34;^\\(;\\|$\\)\u0026#34; /etc/php/cli-php8.1/php.ini grep \u0026#34;^[^;]\u0026#34; /etc/php/cli-php8.1/php.ini grep \u0026#34;^\\(.*\\)\\\u0026gt;.*\\\u0026lt;\\1$\u0026#34; /etc/passwd\n^\\(.*\\)\u0026gt; 匹配1个单词 \\\u0026lt;\\1$ 以前1个单词结尾 ","permalink":"https://tazegi.github.io/post/linux/%E6%96%87%E6%9C%AC/","summary":"文本 vim 匹配行\n. 当前行 2,+5 $ set fileformat=[dos,unix]\nset ff set textwidth=65 xp c-w s c-w v c-w q c-w a ma `a` cat -A -E -n -b 非空行编号 tac rev nl 同 cat -b\ntail -[fn0,0f] 跟踪文件描述符 文件删除无法跟踪\ntail -F 跟踪文件名 cut #1,3,4,5 cut -d: -f1,3-5 /etc/passwd df|tr -s \u0026#34; \u0026#34; \u0026#34;%\u0026#34;|cut -d% -f5 paste paste 两个文件横向合并 paste -s -d: wc #过滤第1行 df|tail -n $(echo $(df|wc -l)-1|bc) sort sort -nt: -k3 /etc/passwd #倒序 sort -nrt: -k3 /etc/passwd uniq 删除前后相邻的重复行 -c count -d duplicate 仅显示重复的行 -u unique 仅显示不曾重复的行 查看连接的ip: ss -nt #去掉第1行 ss -nt|tail -n+2 ss -nt|tail -n+2|tr -s \u0026#34; \u0026#34; :|cut -d: -f6 |sort |uniq -c |sort -nr ss -nt |sed -En \u0026#39;/^ESTAB/s#.","title":"文本"},{"content":" 用户和组 passwd,shaow,group,gshadow sudo getent shadow root getent passwd root useradd -r 创建系统用户 新建用户的相关文件 /etc/default/useradd /etc/skel/* /etc/login.defs 批量创建 #批量创建用户 newusers passwd格式文件 #批量改密码 echo name:password |chpasswd cat p.txt |chpasswd 批量创建用户\necho user{1..10} |xargs -n1 useradd echo user{1..10} |xargs -n1 userdel -r getent passwd 组 查看用户所有的组: groups f 查看组的成员: groupmems -l -g video 权限 chmod -R a+X dir,给目录加上可执行权限,但不影响文件 ","permalink":"https://tazegi.github.io/post/linux/%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84/","summary":" 用户和组 passwd,shaow,group,gshadow sudo getent shadow root getent passwd root useradd -r 创建系统用户 新建用户的相关文件 /etc/default/useradd /etc/skel/* /etc/login.defs 批量创建 #批量创建用户 newusers passwd格式文件 #批量改密码 echo name:password |chpasswd cat p.txt |chpasswd 批量创建用户\necho user{1..10} |xargs -n1 useradd echo user{1..10} |xargs -n1 userdel -r getent passwd 组 查看用户所有的组: groups f 查看组的成员: groupmems -l -g video 权限 chmod -R a+X dir,给目录加上可执行权限,但不影响文件 ","title":"用户和组"},{"content":" IO proc 进程\n/proc/PID/fd/3 指向文件路径 proc/PID/fd[0,1,2] 指向标准输出输入终端 echo $$ (查看当前shell的PID)\ncd /proc/$$/fd echo默认换行\n清空1个文件: echo -n \u0026gt; file 合并多个命令的标准输出\n(ls;date) \u0026gt; file {ls;date} \u0026gt; file 管道符后面的命令心须支持标准输入 管道符默认只支持标准输出,不支持标准错误\nls . /err | tr \u0026#34;a-z\u0026#34; \u0026#34;A-Z\u0026#34; ls . /err 2\u0026gt;\u0026amp;1 | tr \u0026#34;a-z\u0026#34; \u0026#34;A-Z\u0026#34; ls . /err |\u0026amp; tr \u0026#34;a-z\u0026#34; \u0026#34;A-Z\u0026#34; 重定向\n单行重定向 cat \u0026gt; cat.log 多行重定向\ncat \u0026gt; cat.log \u0026lt;\u0026lt;EOF EOF 多行重定向可以嵌入命令 PS2影响多行重定向提示符 tr\ntr \u0026#34;123\u0026#34; \u0026#34;abc\u0026#34;\n1 -\u0026gt; a 2 -\u0026gt; b 3 -\u0026gt; c tr -d abc 删除字母a,b,c tr -s (–squeeze-repeats),去重 tr -c (-C –complement),取补集 发邮件 install postfix install mailx enable postfix mail -s subject name mail -s subject name \u0026lt; mail.txt #反转 echo \u0026#34;FBI Warning\u0026#34; | rev tee | tee | tee -a cat \u0026lt;\u0026lt;EOF | tee test ","permalink":"https://tazegi.github.io/post/linux/io/","summary":"IO proc 进程\n/proc/PID/fd/3 指向文件路径 proc/PID/fd[0,1,2] 指向标准输出输入终端 echo $$ (查看当前shell的PID)\ncd /proc/$$/fd echo默认换行\n清空1个文件: echo -n \u0026gt; file 合并多个命令的标准输出\n(ls;date) \u0026gt; file {ls;date} \u0026gt; file 管道符后面的命令心须支持标准输入 管道符默认只支持标准输出,不支持标准错误\nls . /err | tr \u0026#34;a-z\u0026#34; \u0026#34;A-Z\u0026#34; ls . /err 2\u0026gt;\u0026amp;1 | tr \u0026#34;a-z\u0026#34; \u0026#34;A-Z\u0026#34; ls . /err |\u0026amp; tr \u0026#34;a-z\u0026#34; \u0026#34;A-Z\u0026#34; 重定向\n单行重定向 cat \u0026gt; cat.log 多行重定向\ncat \u0026gt; cat.log \u0026lt;\u0026lt;EOF EOF 多行重定向可以嵌入命令 PS2影响多行重定向提示符 tr\ntr \u0026#34;123\u0026#34; \u0026#34;abc\u0026#34;\n1 -\u0026gt; a 2 -\u0026gt; b 3 -\u0026gt; c tr -d abc 删除字母a,b,c tr -s (–squeeze-repeats),去重 tr -c (-C –complement),取补集 发邮件 install postfix install mailx enable postfix mail -s subject name mail -s subject name \u0026lt; mail.","title":"IO"},{"content":" 硬盘数据的组成 元数据 存放在节点表中\ninode(节点号),使用 df -i 查看 文件类型 权限 UID 所有者 GID 所属组 链接数 文件大小和时间戳 指向磁盘文件的数据块指针\n直接指针\n直接指向数据具体位置 每个指向4k的数据块 总共12个 只能存储48k的数据,超过使用间接指针 间接指针\n指向指针,总大小4k,每个指针4字节,共1024个,每个指向4k数据块 1级指针可以存4m数据 数据本身 如何访问文件\n文件和文件夹的元数据都在节点表中 先找到是那块磁盘,从挂载点依次向下 硬链接\n本质是同1个文件,取了2个名 磁盘真正占的空间只是1个的空间,只是在多个目录中引用了同1个节点号 因为硬链接的文件具有相同的节点号,是同1个文件,所以不能跨分区 ","permalink":"https://tazegi.github.io/post/linux/%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%84%E6%88%90/","summary":" 硬盘数据的组成 元数据 存放在节点表中\ninode(节点号),使用 df -i 查看 文件类型 权限 UID 所有者 GID 所属组 链接数 文件大小和时间戳 指向磁盘文件的数据块指针\n直接指针\n直接指向数据具体位置 每个指向4k的数据块 总共12个 只能存储48k的数据,超过使用间接指针 间接指针\n指向指针,总大小4k,每个指针4字节,共1024个,每个指向4k数据块 1级指针可以存4m数据 数据本身 如何访问文件\n文件和文件夹的元数据都在节点表中 先找到是那块磁盘,从挂载点依次向下 硬链接\n本质是同1个文件,取了2个名 磁盘真正占的空间只是1个的空间,只是在多个目录中引用了同1个节点号 因为硬链接的文件具有相同的节点号,是同1个文件,所以不能跨分区 ","title":"硬盘数据的组成"},{"content":" 文件 文件类型: - d b c l p(pipe) s(socket)\np s都是进程间的通信,不同在于p单向传输,s是双向传输 basename和dirname\n➜ ~ dirname /etc/syslog-ng/syslog-ng.conf /etc/syslog-ng ➜ ~ basename /etc/syslog-ng/syslog-ng.conf syslog-ng.conf 每个文件都有3个时间\nmtime: 文件修改时间 ctime(change time): 文件权限,所有者修改时间 atime(access time): 文件读取时间 查看3个时间: stat ety.org 查看文件类型: file /bin/ls touch 存在的文件刷新时间,不存在的文件创建 在bash无法使用星号, 在zsh会刷新当前文件夹全部文件时间(不会改变子文件夹) 指定刷新某个时间\n-a 仅改变atime和ctime -m 仅改变mtime和ctime -c 如果文件不存在,则不予创建 cp 格式\ncp [OPTION]… [-T] SOURCE DEST\ncp [OPTION]… SOURCE… DIRECTORY\ncp [OPTION]… -t DIRECTORY SOURCE…\ncp会导致时间,所有者发生改变,默认会覆盖文件,不拷贝链接而拷贝原文件 常用选项\n-p (–preserve) 保留属性,same as –preserve=mode,ownership,timestamps -R, -r, –recursive 递归拷贝,拷贝文件夹 -d –no-dereference –preserve=links 不寻找源文件 -a, –archive 常用于备份,same as -dR –preserve=all -f, –force 覆盖不属于该用户的文件\nif an existing destination file cannot be opened, remove it and try again\n在非root帐户家目录,可以删除root的文件\n-u, –update 只有当 SOURCE 文件比目标文件新或者当目标文件丢失时才复制\ncopy only when the SOURCE file is newer than the destination file or when the destination file is missing\n-b 目标存有,覆盖前先备份,后缀 ~ –backup=numbered,后缀 1 -i, –interactive 覆盖前提示 -v, –verbose -n, –no-clobber 不覆盖 ls 时间排序,默认 mtime (文件修改时间)\nll -t ll -t --time=ctime ll -t --time=atime #大小排序 ll -S rename 批量修改文件名 #为所有的conf文件加上.bak后缀 rename \u0026#34;conf\u0026#34; \u0026#34;conf.bak\u0026#34; * rename \u0026#34;.bak\u0026#34; \u0026#34;\u0026#34; *.bak rm #删除所有隐藏文件 rm -rf .[^.]* #拷贝隐藏,非隐藏到目录 cp -av . /opt/ #删除隐藏,非隐藏 rm -rf * .[^.]* #粉碎文件 shred -zvun 5 password.txt ","permalink":"https://tazegi.github.io/post/linux/%E6%96%87%E4%BB%B6/","summary":"文件 文件类型: - d b c l p(pipe) s(socket)\np s都是进程间的通信,不同在于p单向传输,s是双向传输 basename和dirname\n➜ ~ dirname /etc/syslog-ng/syslog-ng.conf /etc/syslog-ng ➜ ~ basename /etc/syslog-ng/syslog-ng.conf syslog-ng.conf 每个文件都有3个时间\nmtime: 文件修改时间 ctime(change time): 文件权限,所有者修改时间 atime(access time): 文件读取时间 查看3个时间: stat ety.org 查看文件类型: file /bin/ls touch 存在的文件刷新时间,不存在的文件创建 在bash无法使用星号, 在zsh会刷新当前文件夹全部文件时间(不会改变子文件夹) 指定刷新某个时间\n-a 仅改变atime和ctime -m 仅改变mtime和ctime -c 如果文件不存在,则不予创建 cp 格式\ncp [OPTION]… [-T] SOURCE DEST\ncp [OPTION]… SOURCE… DIRECTORY\ncp [OPTION]… -t DIRECTORY SOURCE…\ncp会导致时间,所有者发生改变,默认会覆盖文件,不拷贝链接而拷贝原文件 常用选项\n-p (–preserve) 保留属性,same as –preserve=mode,ownership,timestamps -R, -r, –recursive 递归拷贝,拷贝文件夹 -d –no-dereference –preserve=links 不寻找源文件 -a, –archive 常用于备份,same as -dR –preserve=all -f, –force 覆盖不属于该用户的文件","title":"文件"},{"content":" 命令 install install功能相当于cp,chmod,chown,chgrp等相关工具的集合\n#复制文件 # -m 权限 -o 所有者 -g 所属组 install -m 640 -o f -g f test.sh Desktop/ # 创建文件夹 install -m 700 -o f -g f -d testdir 默认是755,适合复制可执行程序\nexpect 复制到远程\n#!/usr/bin/expect spawn scp /etc/fstab 10.0.0.7:/data expect { \u0026#34;yes/no\u0026#34; { send \u0026#34;yes\\n\u0026#34;;exp_continue } \u0026#34;password\u0026#34; { send \u0026#34;xxxxxx\\n\u0026#34; } } expect eof 远程登录主机\n#!/usr/bin/expect spawn ssh 10.0.0.7 expect { \u0026#34;yes/no\u0026#34; { send \u0026#34;yes\\n\u0026#34;;exp_continue } \u0026#34;password\u0026#34; { send \u0026#34;xxxxxx\\n\u0026#34; } } interact expect使用变量\n#!/usr/bin/expect set ip 10.0.0.7 set user root set password xxxxxx set timeout 10 spawn ssh $user@$ip expect { \u0026#34;yes/no\u0026#34; { send \u0026#34;yes\\n\u0026#34;;exp_continue } \u0026#34;password\u0026#34; { send \u0026#34;$password\u0026#34; } } interact expect位置参数\n#!/usr/bin/expect set ip [lindex $argv 0] set user [lindex $argv 1] set password [lindex $argv 2] set timeout 10 spawn ssh $user@$ip expect { \u0026#34;yes/no\u0026#34; { send \u0026#34;yes\\n\u0026#34;;exp_continue } \u0026#34;password\u0026#34; { send \u0026#34;$password\u0026#34; } } interact expect执行多个命令: 远程登录并创建账号\n#!/usr/bin/expect set ip [lindex $argv 0] set user [lindex $argv 1] set password [lindex $argv 2] set timeout 10 spawn ssh $user@$ip expect { \u0026#34;yes/no\u0026#34; { send \u0026#34;yes\\n\u0026#34;;exp_continue } \u0026#34;password\u0026#34; { send \u0026#34;$password\u0026#34; } } expect \u0026#34;]#\u0026#34; { send \u0026#34;useradd haha\\n\u0026#34; } expect \u0026#34;]#\u0026#34; { send \u0026#34;echo xxxxxx |passwd --stdin haha\\n\u0026#34; } send \u0026#34;exit\\n\u0026#34; expect eof man man 5 fstab #查询 man -k keyword #所在目录 man -w ls man -w 5 fstab printf 格式: printf \u0026#34;指定的格式\u0026#34; \u0026#34;文本1\u0026#34; \u0026#34;文本2\u0026#34;\n➜ ~ printf \u0026#34;%s\\n\u0026#34; \u0026#34;1 2 3 4\u0026#34; 1 2 3 4 ➜ ~ printf \u0026#34;%s %s\\n\u0026#34; 1 2 3 4 1 2 3 4 表格\nprintf \u0026#34;%-10s %-10s %-4s %s \\n\u0026#34; 姓名 性别 年龄 体重 小明 男 20 70 小红 女 18 50 zsh打印不工整 ","permalink":"https://tazegi.github.io/post/linux/%E5%91%BD%E4%BB%A4/","summary":"命令 install install功能相当于cp,chmod,chown,chgrp等相关工具的集合\n#复制文件 # -m 权限 -o 所有者 -g 所属组 install -m 640 -o f -g f test.sh Desktop/ # 创建文件夹 install -m 700 -o f -g f -d testdir 默认是755,适合复制可执行程序\nexpect 复制到远程\n#!/usr/bin/expect spawn scp /etc/fstab 10.0.0.7:/data expect { \u0026#34;yes/no\u0026#34; { send \u0026#34;yes\\n\u0026#34;;exp_continue } \u0026#34;password\u0026#34; { send \u0026#34;xxxxxx\\n\u0026#34; } } expect eof 远程登录主机\n#!/usr/bin/expect spawn ssh 10.0.0.7 expect { \u0026#34;yes/no\u0026#34; { send \u0026#34;yes\\n\u0026#34;;exp_continue } \u0026#34;password\u0026#34; { send \u0026#34;xxxxxx\\n\u0026#34; } } interact expect使用变量","title":"命令"},{"content":" 字符集和编码 字符集 二进制的字符的对应关系,如Unicode 编码 决定在磁盘上如何保存,如utf-8类似字体\nUnicode只是约定了那个二进制表示那个文字,没有约定在磁盘上如何保存,就像 echo\n$LANG 查看语言和编码 #-e 输出ASCII文字 echo -e \u0026#34;\\0127\\0130\u0026#34; echo -e \u0026#34;\\x61\\x62\u0026#34; echo -e \u0026#34;\\e[31mwelcome\\e[0m\u0026#34; utf-8,utf-16,utf-32\nutf-8 变长字符集,可能占1,2,3,4 utf-16 要么占2个字节,要么占4个字节 utf-32 固定占4个字节 查看字符的16进制: echo \u0026#34;abc\u0026#34; | hexdump -C\n查看汉字的16进制: echo \u0026#34;饕餮\u0026#34; | hexdump -C xxd od -t x1z 0a 表式换行 查看ASCII表: man ascii 输出8进制: echo -e \u0026#34;\\0127\\0130\u0026#34; \\0代表后面为8进制,127后面是130因为8进制逢8进1 输出16进制: echo -e \u0026#34;\\x57\\x58\u0026#34; ","permalink":"https://tazegi.github.io/post/linux/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E7%BC%96%E7%A0%81/","summary":" 字符集和编码 字符集 二进制的字符的对应关系,如Unicode 编码 决定在磁盘上如何保存,如utf-8类似字体\nUnicode只是约定了那个二进制表示那个文字,没有约定在磁盘上如何保存,就像 echo\n$LANG 查看语言和编码 #-e 输出ASCII文字 echo -e \u0026#34;\\0127\\0130\u0026#34; echo -e \u0026#34;\\x61\\x62\u0026#34; echo -e \u0026#34;\\e[31mwelcome\\e[0m\u0026#34; utf-8,utf-16,utf-32\nutf-8 变长字符集,可能占1,2,3,4 utf-16 要么占2个字节,要么占4个字节 utf-32 固定占4个字节 查看字符的16进制: echo \u0026#34;abc\u0026#34; | hexdump -C\n查看汉字的16进制: echo \u0026#34;饕餮\u0026#34; | hexdump -C xxd od -t x1z 0a 表式换行 查看ASCII表: man ascii 输出8进制: echo -e \u0026#34;\\0127\\0130\u0026#34; \\0代表后面为8进制,127后面是130因为8进制逢8进1 输出16进制: echo -e \u0026#34;\\x57\\x58\u0026#34; ","title":"字符集和编码"},{"content":" 会话管理 screen实现屏幕共享\n#开启help会话 screen -S help #查看 screen -ls #加入 screen -x help #退出共享 C-a,d ","permalink":"https://tazegi.github.io/post/linux/%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/","summary":" 会话管理 screen实现屏幕共享\n#开启help会话 screen -S help #查看 screen -ls #加入 screen -x help #退出共享 C-a,d ","title":"会话管理"},{"content":" 日期和时间 #set date 月 日 时 分 年.秒 date 122807002022.30 date 010100002000.00 #查看硬件时间 sudo hwclock #校正系统时间 hwclock -s --hctosys #校正硬件时间 hwclock -w --systohc #日历 #显示今年 cal -y cal 2022 cal 1 2023 cal 9 1752 show\ndate -d now date -d yesterday date -d tomorrow date -d \u0026#34;-2 day\u0026#34; date -d \u0026#34;100 day\u0026#34; #秒-\u0026gt;日期 date +%s date -d @1672247243 +%F\\ %T #查看前天是星期几 date -d \u0026#34;-2 day\u0026#34; +%w 定时开关机 #关机 halt #十分钟后关机 shutdown +10 #十分钟后关机 shutdown 08:00 #取消 shutdown -c #十分钟后重启 shutdown -r +10 ","permalink":"https://tazegi.github.io/post/linux/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/","summary":" 日期和时间 #set date 月 日 时 分 年.秒 date 122807002022.30 date 010100002000.00 #查看硬件时间 sudo hwclock #校正系统时间 hwclock -s --hctosys #校正硬件时间 hwclock -w --systohc #日历 #显示今年 cal -y cal 2022 cal 1 2023 cal 9 1752 show\ndate -d now date -d yesterday date -d tomorrow date -d \u0026#34;-2 day\u0026#34; date -d \u0026#34;100 day\u0026#34; #秒-\u0026gt;日期 date +%s date -d @1672247243 +%F\\ %T #查看前天是星期几 date -d \u0026#34;-2 day\u0026#34; +%w 定时开关机 #关机 halt #十分钟后关机 shutdown +10 #十分钟后关机 shutdown 08:00 #取消 shutdown -c #十分钟后重启 shutdown -r +10 ","title":"日期和时间"},{"content":" 编码格式 windows和linux文本文件的差异\n换行的表示\nlinux: 0a LF \\n windows: 0d 0a CRLF \\r\\n \\r 回车 \\n 换行 转化: dos2unix 编码转换:iconv\n#查看支持转换的编码 iconv -l #将gb2312转换为utf8 #-f from iconv -f GB2312 windows.txt -o windows1.txt ","permalink":"https://tazegi.github.io/post/linux/%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/","summary":" 编码格式 windows和linux文本文件的差异\n换行的表示\nlinux: 0a LF \\n windows: 0d 0a CRLF \\r\\n \\r 回车 \\n 换行 转化: dos2unix 编码转换:iconv\n#查看支持转换的编码 iconv -l #将gb2312转换为utf8 #-f from iconv -f GB2312 windows.txt -o windows1.txt ","title":"编码格式"},{"content":" 技巧 结合多条命令输出\n{uname -r;uname -m} CAPS或\u0026lt;\u0026gt;表示变化的数据 查看文件的16进制\nhexdump -C awk.org bc十进制转二进制\nbc obase=2 4 查看所有隐藏文件\nls -Ad .* 查看磁盘开头512个字节\nsudo hexdump -C -n 512 /dev/nvme0n1p1 uname,who\n#release uname -r #all uname -a #查看登录了几个用户 who echo {000..10..2} M-\u0026lt;num\u0026gt; l /etc\n#登录成功的欢迎提示 /etc/motd #登录前提示 /etc/issue #查看当前shell以及可用shell echo $SHELL cat /etc/shells #查看操作系统 cat /etc/os-release 查看cpu\nlscpu cat /proc/cpuinfo 带颜色输出\n#-e 支持\\ #[31m 红色 #[0m 结束 echo -e \u0026#34;\\e[31mwelcome\\e[0m\u0026#34; whereis 和 whatis 结合使用查看man目录和命令的关系\n➜ ~ whatis echo echo (1) - display a line of text echo (3x) - curses input options ➜ ~ whereis echo echo: /bin/echo /usr/share/man/man3/echo.3x.bz2 /usr/share/man/man1/echo.1.bz2 自动挂载 autofs 去wang的家目录\ncd ~wang ~- 前1个工作目录\ncat ~-/awk.org #相当于 cat $OLDPWD/awk.org 拷贝隐藏,非隐藏到目录\ncp -av . /opt/ 创建 -f 文件\ntouch ./-f rm ./-f 查看从1970到今天经过的天数\necho `date +%s`/86400 |bc date +%F/%T 复制file1的acl权限给file2\ngetfacl file1 |setfacl --set-file=- file2 patch -b 备份 bash语法检查: bash -n\n调试: bash -x 特殊条件\nwhile : 同 while true 查看网卡驱动文件\n➜ ~ ethtool -i eth0 driver: r8169 ➜ ~ modinfo -n r8169 /lib/modules/5.15.88-gentoo-dist/kernel/drivers/net/ethernet/realtek/r8169.ko rev反转\n#反转 echo \u0026#34;FBI Warning\u0026#34; | rev 排除空行和#开头的行\ngrep -v \u0026#34;^;\u0026#34; /etc/php/cli-php8.1/php.ini |grep -v ^$ grep -v \u0026#34;^;\\|^$\u0026#34; /etc/php/cli-php8.1/php.ini grep -v \u0026#34;^\\(;\\|$\\)\u0026#34; /etc/php/cli-php8.1/php.ini grep \u0026#34;^[^;]\u0026#34; /etc/php/cli-php8.1/php.ini grep \u0026#34;^\\(.*\\)\\\u0026gt;.*\\\u0026lt;\\1$\u0026#34; /etc/passwd\n^\\(.*\\)\u0026gt; 匹配1个单词 \\\u0026lt;\\1$ 以前1个单词结尾 ","permalink":"https://tazegi.github.io/post/linux/%E6%8A%80%E5%B7%A7/","summary":"技巧 结合多条命令输出\n{uname -r;uname -m} CAPS或\u0026lt;\u0026gt;表示变化的数据 查看文件的16进制\nhexdump -C awk.org bc十进制转二进制\nbc obase=2 4 查看所有隐藏文件\nls -Ad .* 查看磁盘开头512个字节\nsudo hexdump -C -n 512 /dev/nvme0n1p1 uname,who\n#release uname -r #all uname -a #查看登录了几个用户 who echo {000..10..2} M-\u0026lt;num\u0026gt; l /etc\n#登录成功的欢迎提示 /etc/motd #登录前提示 /etc/issue #查看当前shell以及可用shell echo $SHELL cat /etc/shells #查看操作系统 cat /etc/os-release 查看cpu\nlscpu cat /proc/cpuinfo 带颜色输出\n#-e 支持\\ #[31m 红色 #[0m 结束 echo -e \u0026#34;\\e[31mwelcome\\e[0m\u0026#34; whereis 和 whatis 结合使用查看man目录和命令的关系","title":"技巧"},{"content":" 通配符 #去wang的家目录 cd ~wang #~- 前1个工作目录 #访问上次工作目录的awk.org而不需要用-切换文件夹 cat ~-/awk.org #同 cat $OLDPWD/awk.org #? 任意一个字符 #查找7个字符的文件 ll ??????? #会包含大写字母,顺序是小大小大.a-A-b-B-c 没有大写C ls [a-c].txt #要包含全部大小写a,b,c ls [a-C].txt #C-d-D-e-E 没有小写c ls [C-E].txt #匹配所有大小写字母 ls [a-Z].txt 星号不会匹配包含隐藏文件\n#预定义的字符 [:digit:] [:lower:] [:upper:] [:alpha:] 任意大小写字母 [:alnum:] 任意数字或字母 [:blank:] 水平空白字符 [:space:] 水平或垂直空白字符 [:punct:] 标点符号 [:print:] 可打印字符 [:cntrl:] 控制(非打印)字符 [:graph:] 图形字符 [:xdigit:] 十六进制字符 [],[^]同正则\n#查看所有隐藏文件: ls -Ad .* #不是所有命令都支持通配符 touch file*.log #生成随机密码 cat /dev/urandom 什么符号都有 tr -dc \u0026#34;[:alnum:]\u0026#34; \u0026lt; /dev/urandom |head -c 12 openssl rand -base64 12 点不是通配符\n","permalink":"https://tazegi.github.io/post/linux/%E9%80%9A%E9%85%8D%E7%AC%A6/","summary":"通配符 #去wang的家目录 cd ~wang #~- 前1个工作目录 #访问上次工作目录的awk.org而不需要用-切换文件夹 cat ~-/awk.org #同 cat $OLDPWD/awk.org #? 任意一个字符 #查找7个字符的文件 ll ??????? #会包含大写字母,顺序是小大小大.a-A-b-B-c 没有大写C ls [a-c].txt #要包含全部大小写a,b,c ls [a-C].txt #C-d-D-e-E 没有小写c ls [C-E].txt #匹配所有大小写字母 ls [a-Z].txt 星号不会匹配包含隐藏文件\n#预定义的字符 [:digit:] [:lower:] [:upper:] [:alpha:] 任意大小写字母 [:alnum:] 任意数字或字母 [:blank:] 水平空白字符 [:space:] 水平或垂直空白字符 [:punct:] 标点符号 [:print:] 可打印字符 [:cntrl:] 控制(非打印)字符 [:graph:] 图形字符 [:xdigit:] 十六进制字符 [],[^]同正则\n#查看所有隐藏文件: ls -Ad .* #不是所有命令都支持通配符 touch file*.log #生成随机密码 cat /dev/urandom 什么符号都有 tr -dc \u0026#34;[:alnum:]\u0026#34; \u0026lt; /dev/urandom |head -c 12 openssl rand -base64 12 点不是通配符","title":"通配符"},{"content":" 命令的帮助用法 ➜ ~ whatis cal ls: nothing appropriate.\nsudo mandb #查看描述 whatis cal #等价于 man -f cal #内部命令 help history ","permalink":"https://tazegi.github.io/post/linux/%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B8%AE%E5%8A%A9%E7%94%A8%E6%B3%95/","summary":" 命令的帮助用法 ➜ ~ whatis cal ls: nothing appropriate.\nsudo mandb #查看描述 whatis cal #等价于 man -f cal #内部命令 help history ","title":"命令的帮助用法"},{"content":" history #清空 history -c #删除第offset个命令 #zsh无效 history -d num #显示最近n条 #bash history n #zsh history -n !n !-n #调用最近开头为d的命令 !d #打印命令,不执行 !d:p #包含 !?at 仅bash\n#追加本次会话新执行的命令列表至历史文件 history -a #显示时间 HISTTIMEFORMAT=\u0026#34;%F %T \u0026#34; #获取上个命令的全部参数 !* !:1 !^ !$ ","permalink":"https://tazegi.github.io/post/linux/history/","summary":" history #清空 history -c #删除第offset个命令 #zsh无效 history -d num #显示最近n条 #bash history n #zsh history -n !n !-n #调用最近开头为d的命令 !d #打印命令,不执行 !d:p #包含 !?at 仅bash\n#追加本次会话新执行的命令列表至历史文件 history -a #显示时间 HISTTIMEFORMAT=\u0026#34;%F %T \u0026#34; #获取上个命令的全部参数 !* !:1 !^ !$ ","title":"History"},{"content":" 内部命令 查看 #内部命令:包含在bash中,在内存中 help bash #查看所有内部命令 enable #搜索内部命令的外部命令 type -a echo 禁用内部命令 #禁用内部命令 #help中echo前有星号,说明ehco被禁用 enable -n echo whereis #查看命令文档路径 whereis ls #查看全部缓存的命令 hash #清楚缓存 hash -r #清楚某条缓存 hash -r hostname 命令优先级 别名\u0026gt;内部\u0026gt;外部\n#取消别名功能 \\ls ","permalink":"https://tazegi.github.io/post/linux/%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4/","summary":" 内部命令 查看 #内部命令:包含在bash中,在内存中 help bash #查看所有内部命令 enable #搜索内部命令的外部命令 type -a echo 禁用内部命令 #禁用内部命令 #help中echo前有星号,说明ehco被禁用 enable -n echo whereis #查看命令文档路径 whereis ls #查看全部缓存的命令 hash #清楚缓存 hash -r #清楚某条缓存 hash -r hostname 命令优先级 别名\u0026gt;内部\u0026gt;外部\n#取消别名功能 \\ls ","title":"内部命令"},{"content":" 内核升级 download\nemerge --ask --update --deep --with-bdeps=y --newuse sys-kernel/gentoo-sources eselect kernel set 1 eselect kernel list cd /usr/src/linux copy\ncp /boot/config-3.14.14-gentoo /usr/src/linux/.config zcat /proc/config.gz \u0026gt; /usr/src/linux/.config merge\nmake oldconfig #字符串“（NEW）”在该行结束时标记该选项是新的。左边的方括号中的字符串是可能的答案：“Y”是，“N”不是，“m”模块，或者“？”显示帮助。推荐(或者说是默认)答案是大写（“Y”）。帮助说明解释了选项或驱动程序。 #当外部内核模块被安装 (如 NVIDIA 或 ZFS)，在制作内核前可能需要运行 make modules_prepare ，在这里 有它的描述。在构建上述额外的模块之前，一些模块在内核构建之前不能被安装或准备好。 compare\n#另外，内核提供了一个脚本，可以干净地比较两个配置文件，即使已经移动了文件中的选项。 /usr/src/linux/scripts/diffconfig .config.old .config compile\nmake menuconfig #根据系统可用的速度和内核数量，构建内核可能需要相当长的时间。如果已知系统中 CPU 核的数量，可以使用-jN (其中 N 是可用核的数量加1)选项来加速复杂的处理过程。例如，一个双核处理器包含两个逻辑核加一个(2 + 1)。确定可用核心数量的一个简单方法是运行 nproc 命令: nproc make -j13 install\nmake modules_install make install sudo genkernel --lvm --install initramfs #包含内核模块的包可以使用@module-rebuild命令重新编译 sudo emerge --ask @module-rebuild ","permalink":"https://tazegi.github.io/post/linux/%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7/","summary":" 内核升级 download\nemerge --ask --update --deep --with-bdeps=y --newuse sys-kernel/gentoo-sources eselect kernel set 1 eselect kernel list cd /usr/src/linux copy\ncp /boot/config-3.14.14-gentoo /usr/src/linux/.config zcat /proc/config.gz \u0026gt; /usr/src/linux/.config merge\nmake oldconfig #字符串“（NEW）”在该行结束时标记该选项是新的。左边的方括号中的字符串是可能的答案：“Y”是，“N”不是，“m”模块，或者“？”显示帮助。推荐(或者说是默认)答案是大写（“Y”）。帮助说明解释了选项或驱动程序。 #当外部内核模块被安装 (如 NVIDIA 或 ZFS)，在制作内核前可能需要运行 make modules_prepare ，在这里 有它的描述。在构建上述额外的模块之前，一些模块在内核构建之前不能被安装或准备好。 compare\n#另外，内核提供了一个脚本，可以干净地比较两个配置文件，即使已经移动了文件中的选项。 /usr/src/linux/scripts/diffconfig .config.old .config compile\nmake menuconfig #根据系统可用的速度和内核数量，构建内核可能需要相当长的时间。如果已知系统中 CPU 核的数量，可以使用-jN (其中 N 是可用核的数量加1)选项来加速复杂的处理过程。例如，一个双核处理器包含两个逻辑核加一个(2 + 1)。确定可用核心数量的一个简单方法是运行 nproc 命令: nproc make -j13 install\nmake modules_install make install sudo genkernel --lvm --install initramfs #包含内核模块的包可以使用@module-rebuild命令重新编译 sudo emerge --ask @module-rebuild ","title":"内核升级"}]